{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Unit tests are great for peace of mind and reducing software errors. You should always make the time to test.</p> <p>The key difference in the test-driven development lifecycle is that before writing the feature code, a test is written.(1)</p> <ol> <li> <p>Initially, the test would be empty and will fail because the feature function does not exist yet. Now write a simple feature function, and the test will pass.</p> <p>Update the test with more checks. The test might fail. Update the feature function again, and the test will pass. Keep doing this until all the test cases are covered.</p> <p>In the end, you will have a function that is well-unit-tested. Do this for all features, and you will have a nearly bug-free code. Nearly bug-free because there are many other factors responsible for zero-defect software.</p> <ul> <li>Mastering Test-Driven Development with React by Ravi Kumar Gupta</li> </ul> </li> </ol>"},{"location":"#types-of-testing","title":"Types of Testing","text":""},{"location":"#js-event-loop","title":"JS Event Loop","text":"<ul> <li>\u2728\u267b\ufe0f JavaScript Visualized: Event Loop</li> </ul>"},{"location":"#js-event-loop-reference","title":"JS Event Loop Reference","text":"<ul> <li>Youtube: JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue</li> <li>Dev.to Blog: JavaScript Visualized: Event Loop </li> <li>Source: JavaScript Visualized: Event Loop, Web APIs, (Micro)task Queue</li> </ul>"},{"location":"#book","title":"Book","text":""},{"location":"#reference","title":"Reference","text":"<ul> <li>Top 11 JavaScript Testing Frameworks: Everything You Need to Know</li> <li> <p>JavaScript unit testing frameworks in 2024: A comparison</p> </li> <li> <p>How to write your first unit test in JavaScript</p> </li> <li> <p>JS Unit Testing Frameworks Comparison</p> </li> <li> <p>Book</p> </li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/","title":"Beginner's Guide: Switching from Jest to Vitest in React Projects","text":"","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#beginners-guide-switching-from-jest-to-vitest-in-react-projects","title":"Beginner's Guide: Switching from Jest to Vitest in React Projects","text":"<p>Testing is an essential part of building stable and maintainable React applications. If you've been using Jest, you're in good company\u2014it's been the default choice for years. But a new contender has been making waves: Vitest.</p> <p>In this post, we\u2019ll walk you through what Vitest is, why you might want to try it, and how to get started\u2014especially if you\u2019re coming from a Jest background.</p>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#what-is-vitest","title":"\ud83e\uddea What is Vitest?","text":"<p>Vitest is a blazing-fast unit test framework built on top of Vite. It supports ESM, is deeply integrated with the Vite dev server, and has Jest-compatible APIs\u2014making it super appealing for React developers looking for speed and simplicity.</p> <p>Key benefits of Vitest:</p> <ul> <li>\u26a1 Fast startup with Vite integration</li> <li>\ud83e\udde9 Works with ESM and TypeScript out of the box</li> <li>\ud83c\udfad Jest-like syntax and matchers</li> <li>\ud83e\udde0 Built-in mocking and snapshot support</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#why-switch-from-jest","title":"\ud83e\udd14 Why switch from Jest?","text":"<p>Jest is battle-tested, but it can feel slow\u2014especially in large projects. It uses a separate Node.js environment, which can lead to inconsistencies between your test and dev environments.</p> <p>Vitest, on the other hand:</p> <ul> <li>Shares the dev server with your Vite app (no more duplicated builds)</li> <li>Has near-instant feedback on file changes</li> <li>Offers a smoother developer experience in modern frontend stacks</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#getting-started-with-vitest-in-a-react-project","title":"\ud83d\ude80 Getting Started with Vitest in a React Project","text":"<p>Let\u2019s create a simple React app and set up Vitest. If you already have a Vite + React project, you can skip to step 3.</p>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#1-create-a-vite-react-app","title":"1. Create a Vite + React App","text":"<pre><code>npm create vite@latest my-react-vitest-app --template react\ncd my-react-vitest-app\nnpm install\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#2-install-vitest-and-react-testing-tools","title":"2. Install Vitest and React Testing Tools","text":"<pre><code>npm install -D vitest @testing-library/react @testing-library/jest-dom\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#3-configure-vitest","title":"3. Configure Vitest","text":"<p>Update <code>vite.config.ts</code> (or <code>.js</code>) to include the <code>test</code> config:</p> <pre><code>// vite.config.ts\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: \"jsdom\",\n    setupFiles: \"./src/setupTests.ts\",\n  },\n});\n</code></pre> <p>Create a setup file like <code>src/setupTests.ts</code>:</p> <pre><code>// src/setupTests.ts\nimport \"@testing-library/jest-dom\";\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#4-write-your-first-test","title":"4. Write Your First Test","text":"<pre><code>// src/components/Hello.test.tsx\nimport { render, screen } from \"@testing-library/react\";\nimport Hello from \"./Hello\";\n\ntest(\"renders hello message\", () =&gt; {\n  render(&lt;Hello name=\"React\" /&gt;);\n  expect(screen.getByText(\"Hello, React!\")).toBeInTheDocument();\n});\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#5-run-the-tests","title":"5. Run the Tests","text":"<pre><code>npx vitest run\n</code></pre> <p>Or run in watch mode:</p> <pre><code>npx vitest\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#jest-vs-vitest-syntax-comparison","title":"\u2705 Jest vs Vitest: Syntax Comparison","text":"Feature Jest Vitest Test function <code>test()</code> / <code>it()</code> <code>test()</code> / <code>it()</code> Assertions <code>expect().toBe()</code> <code>expect().toBe()</code> Setup file <code>setupFilesAfterEnv</code> in <code>jest.config</code> <code>setupFiles</code> in <code>vite.config</code> Mock functions <code>jest.fn()</code> <code>vi.fn()</code> Snapshot tests <code>expect(...).toMatchSnapshot()</code> <code>expect(...).toMatchSnapshot()</code> <p>You can even alias <code>vi</code> as <code>jest</code> if you want to port code quickly:</p> <pre><code>// Optional: alias vi to jest\nglobalThis.jest = vi;\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#final-thoughts","title":"\ud83e\udded Final Thoughts","text":"<p>Vitest is a modern alternative to Jest that fits naturally with Vite-powered projects. If you're already using Vite for React development, Vitest offers a seamless, fast, and familiar testing experience with a gentle learning curve.</p>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#useful-resources","title":"\ud83d\udee0\ufe0f Useful Resources","text":"<ul> <li>Vitest Docs</li> <li>Testing Library for React</li> <li>Migrating from Jest to Vitest</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/","title":"Choosing Between Jest, Vitest, and React Testing Library","text":"","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#choosing-between-jest-vitest-and-react-testing-library","title":"Choosing Between Jest, Vitest, and React Testing Library","text":"<p>When you're starting out with testing in JavaScript or React, you'll quickly come across three major tools: Jest, Vitest, and React Testing Library. While they often appear together, they serve different purposes. In this post, we'll break down what each one does, when to use them, and which combination is best for your project.</p> <p>\ud83e\uddea Beginner-friendly guide to testing frameworks for React projects</p>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#overview","title":"\ud83d\udd0d Overview","text":"Tool Type Purpose Jest Test Runner Run JavaScript/React tests Vitest Test Runner Fast, modern alternative for Vite users React Testing Library Component Testing Test React components from a user's view","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#jest","title":"\u2705 Jest","text":"<p>Jest is the most widely used testing framework in the JavaScript world. It comes pre-configured with tools like Create React App (CRA).</p> <p>Features:</p> <ul> <li>Built-in test runner and assertion library</li> <li>Snapshot testing support</li> <li>Mocking and spies</li> <li>Works with React, Node.js, and TypeScript</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re using Create React App</li> <li>Your project does not use Vite</li> <li>You want a mature, stable testing setup</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#vitest","title":"\u26a1 Vitest","text":"<p>Vitest is a modern alternative to Jest, built specifically for the Vite ecosystem. It\u2019s designed for speed and seamless Vite integration.</p> <p>Features:</p> <ul> <li>Lightning-fast test runs</li> <li>Uses native ES modules</li> <li>Shares config with your <code>vite.config.ts</code></li> <li>Compatible with Jest-style syntax (<code>describe</code>, <code>expect</code>, etc.)</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re using Vite with React or Vue</li> <li>You want faster test performance</li> <li>You prefer modern tools with better DX</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#react-testing-library","title":"\ud83e\uddea React Testing Library","text":"<p>React Testing Library (RTL) is not a test runner. It's a helper library that lets you test React components as a user would interact with them.</p> <p>Features:</p> <ul> <li>Encourages good testing practices</li> <li>Focuses on accessibility and user interactions</li> <li>Works with both Jest and Vitest</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re testing React components</li> <li>You care about testing UI like a user would</li> <li>You\u2019re already using Jest or Vitest</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#should-you-use-jest-or-vitest","title":"\u2694\ufe0f Should You Use Jest or Vitest?","text":"<p>You should only use one, not both.</p> Your Project Uses Use This Create React App \u2705 Jest Vite + React \u2705 Vitest Legacy Node project \u2705 Jest New, modern React app \u2705 Vitest","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#final-recommendation-for-beginners","title":"\u2705 Final Recommendation for Beginners","text":"You Are Using Install These Create React App <code>jest</code> (comes with CRA), <code>@testing-library/react</code> Vite + React <code>vitest</code>, <code>@testing-library/react</code>, <code>jsdom</code>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#sample-vitest-react-testing-library-setup","title":"\ud83d\udee0\ufe0f Sample Vitest + React Testing Library Setup","text":"<p>Install:</p> <pre><code>npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom\n</code></pre> <p>In <code>vite.config.ts</code>:</p> <pre><code>import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: './setupTests.ts',\n  },\n})\n</code></pre> <p>In <code>setupTests.ts</code>:</p> <pre><code>import '@testing-library/jest-dom'\n</code></pre>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#summary","title":"\ud83d\udccc Summary","text":"<ul> <li>Use Jest or Vitest \u2014 not both.</li> <li>Pair either one with React Testing Library for component testing.</li> <li>Use Jest for CRA, Vitest for Vite.</li> <li>Focus on writing tests that reflect real user behavior.</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/","title":"Understanding the Difference Between jsdom and @testing-library/jest-dom","text":"","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#understanding-the-difference-between-jsdom-and-testing-libraryjest-dom","title":"Understanding the Difference Between <code>jsdom</code> and <code>@testing-library/jest-dom</code>","text":"<p>Yes, exactly \u2014 <code>jsdom</code> and <code>@testing-library/jest-dom</code> are completely different things, but they often work together in testing setups.</p> <p>vitest: The testing framework.</p> Installation<pre><code>npm install --save-dev vitest\n</code></pre> <p>After installing <code>vitest</code>, we will have to add a script to our <code>package.json</code> file to run our test.</p> package.json<pre><code>{\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n</code></pre> <p>By default, Vitest requires you to import basic functions like describe and expect. To make these available as globals, you\u2019ll need to make a couple of configuration tweaks. (1)</p> <ol> <li> <p>First, update <code>vite.config.tsx</code> to use the <code>defineConfig</code> function from <code>vitest/config</code>, and enable the <code>test.globals</code> flag:</p> vite.config.ts<pre><code>import { defineConfig } from \"vitest/config\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n  },\n});\n</code></pre> <p>Test Drivern React, Second Edition by Trevor Burnham</p> </li> </ol>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#what-is-jsdom","title":"What is <code>jsdom</code>?","text":"<ul> <li><code>jsdom</code> is a JavaScript-based implementation of the browser\u2019s DOM.</li> <li>It runs inside Node.js to simulate a real browser environment.</li> <li>Because Node.js does not have a native DOM, <code>jsdom</code> provides essential browser APIs like <code>window</code>, <code>document</code>, and <code>HTMLElement</code>.</li> <li>This environment lets you render UI components (React, Vue, etc.) and interact with the DOM during tests.</li> <li>Without <code>jsdom</code>, you can\u2019t test UI code that depends on the DOM in Node.js.</li> </ul> Installation<pre><code>npm install jsdom --save-dev\n</code></pre> <p>After installing <code>jsdom</code>, we have to include <code>jsdom</code> in the Vite configuration file, which you can find at the root of your React project <code>vite.config.js</code></p> <pre><code>import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    // \ud83d\udc4b add the line below to add jsdom to vite\n    environment: \"jsdom\",\n  },\n});\n</code></pre>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#what-is-testing-libraryjest-dom","title":"What is <code>@testing-library/jest-dom</code>?","text":"<ul> <li><code>@testing-library/jest-dom</code> is a library that adds custom Jest matchers for asserting on DOM nodes.</li> <li> <p>Examples of matchers it provides:</p> <ul> <li><code>.toBeInTheDocument()</code></li> <li><code>.toHaveTextContent()</code></li> <li><code>.toHaveAttribute()</code></li> <li><code>.toHaveClass()</code></li> </ul> </li> <li> <p>These matchers make your test assertions more readable and expressive.</p> </li> <li>However, since they assert on DOM elements, they require a DOM environment to work.</li> </ul> Installation<pre><code>npm install @testing-library/react @testing-library/jest-dom --save-dev\n</code></pre> Explanation <ul> <li><code>@testing-library/react</code>: Provides utilities to test React components.</li> <li><code>@testing-library/jest-dom</code>: Adds custom matchers to Jest and Vitest for DOM node assertions.</li> <li><code>@testing-library/user-event</code>: Simulates user interactions with the DOM.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#how-do-jsdom-and-jest-dom-work-together","title":"How Do <code>jsdom</code> and <code>jest-dom</code> Work Together?","text":"<code>jsdom</code> <code>@testing-library/jest-dom</code> Simulates the browser\u2019s DOM Provides expressive matchers for testing DOM Enables rendering and DOM APIs Makes assertions on DOM nodes easier Used as a test environment in Node Extends Jest or Vitest assertion library In short: <ul> <li><code>jsdom</code> creates the DOM environment your components run in.</li> <li><code>jest-dom</code> provides nicer assertions you use to test the DOM elements in that environment.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#do-you-always-need-both","title":"Do You Always Need Both?","text":"<ul> <li>No, but often yes!</li> <li>If you test pure functions or logic without DOM, you don\u2019t need <code>jsdom</code> or <code>jest-dom</code>.</li> <li>If you test UI components or DOM manipulation, you need <code>jsdom</code> to simulate the DOM and <code>jest-dom</code> to write readable assertions.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#example-vitest-setup","title":"Example Vitest Setup","text":"<pre><code>// vitest.config.ts\nimport { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    environment: \"jsdom\", // enable jsdom environment\n    setupFiles: \"./setupTests.ts\",\n  },\n});\n</code></pre> <pre><code>// setupTests.ts\nimport \"@testing-library/jest-dom\"; // import jest-dom matchers\n</code></pre>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#summary","title":"Summary","text":"Tool Purpose <code>jsdom</code> Simulates browser DOM in Node.js tests <code>@testing-library/jest-dom</code> Adds readable matchers to assert on DOM nodes <p>Using both together helps you write effective and easy-to-understand frontend tests.</p>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#reference","title":"Reference","text":"<ul> <li>Medium: Vitest with React Testing Library In React(created with Vite)</li> <li>Vitest with React Testing Library</li> <li>Testing React Applications with Vitest: A Comprehensive Guide </li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/","title":"Controlled vs Uncontrolled Components in React","text":"","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#controlled-vs-uncontrolled-components-in-react","title":"Controlled vs Uncontrolled Components in React","text":"<p>React components are often described as controlled or uncontrolled depending on how their <code>state</code> is managed. While this terminology is usually applied to form elements, the concept is useful across any kind of component.</p> <pre><code>\ud83d\udd01 General Concept (Outside of Forms)\n\nImagine a component that shows a toggle between \u201cOn\u201d and \u201cOff\u201d:\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#what-do-controlled-and-uncontrolled-mean","title":"\ud83e\udde0 What Do Controlled and Uncontrolled Mean?","text":"<ul> <li>Controlled Component: The parent component fully manages the <code>state</code> and passes it as <code>props</code>.</li> <li>Uncontrolled Component: The component maintains its own internal state.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#controlled-example-toggle-buttonnon-form","title":"\u2705 Controlled Example (Toggle Button)/(Non-form)","text":"<p>In a controlled component, the parent holds the state and controls the component behavior.</p> <pre><code>function Toggle({ isOn, onToggle }) {\n  return &lt;button onClick={onToggle}&gt;{isOn ? \"On\" : \"Off\"}&lt;/button&gt;;\n}\n\nfunction App() {\n  const [isOn, setIsOn] = useState(false);\n\n  return &lt;Toggle isOn={isOn} onToggle={() =&gt; setIsOn(!isOn)} /&gt;;\n}\n</code></pre> <ul> <li><code>Toggle</code> doesn't own its state.</li> <li>Parent (<code>App</code>) is the single source of truth.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#uncontrolled-example-toggle-buttonnon-form","title":"\u274c Uncontrolled Example (Toggle Button)/(Non-form)","text":"<p>In an uncontrolled component, the component manages its own state:</p> <pre><code>function Toggle() {\n  const [isOn, setIsOn] = useState(false);\n\n  return &lt;button onClick={() =&gt; setIsOn(!isOn)}&gt;{isOn ? \"On\" : \"Off\"}&lt;/button&gt;;\n}\n</code></pre> <ul> <li><code>Toggle</code> is self-contained.</li> <li>Parent has no visibility or control over state.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#hybrid-pattern","title":"\ud83e\udde9 Hybrid Pattern","text":"<p>Some components allow both controlled and uncontrolled usage:</p> <pre><code>function Toggle({ isOn: controlledIsOn, onToggle }) {\n  const [internalIsOn, setInternalIsOn] = useState(false);\n  const isControlled = controlledIsOn !== undefined;\n  const isOn = isControlled ? controlledIsOn : internalIsOn;\n\n  function handleClick() {\n    if (isControlled) {\n      onToggle?.();\n    } else {\n      setInternalIsOn(!internalIsOn);\n    }\n  }\n\n  return &lt;button onClick={handleClick}&gt;{isOn ? \"On\" : \"Off\"}&lt;/button&gt;;\n}\n</code></pre> <ul> <li>Works in both controlled and uncontrolled modes.</li> <li>Often used in UI libraries (like Material-UI).</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#when-to-use-what","title":"\ud83e\udd14 When to Use What?","text":"Scenario Use Controlled Use Uncontrolled Parent needs control \u2705 \u274c Internal logic is isolated \u274c \u2705 Component used in library/API \u2705 / Hybrid \u2705 Simple use without customization \u274c \u2705","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#summary","title":"\ud83e\udded Summary","text":"<ul> <li> <p>Controlled: Parent manages all state and logic.</p> </li> <li> <p>Uncontrolled: Component manages itself.</p> </li> <li> <p>Use controlled when you need predictability and coordination between components.</p> </li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/","title":"Controlled vs Uncontrolled Form Components in React","text":"","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#controlled-vs-uncontrolled-form-components-in-react","title":"Controlled vs Uncontrolled Form Components in React","text":"<p>One of the most fundamental concepts in building forms with React is the difference between controlled and uncontrolled components. Understanding this difference helps you decide how to handle form input in a way that best fits your application's needs.</p>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#what-are-controlled-and-uncontrolled-components","title":"\ud83d\udccc What Are Controlled and Uncontrolled Components?","text":"","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#controlled-form-component","title":"\u2705 Controlled Form Component","text":"<p>A controlled component is a form element (like <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, or <code>&lt;select&gt;</code>) whose value is controlled by React state. Every change in the input is handled through a React <code>onChange</code> handler that updates the component\u2019s state.</p> Quote <ul> <li>The input\u2019s value comes from the component\u2019s <code>state</code>.</li> <li>Every change in the input is handled by an <code>onChange</code> handler that updates the <code>state</code>.</li> </ul> <pre><code>function ControlledForm() {\n  const [email, setEmail] = useState(\"\");\n\n  const handleSubmit = (e) =&gt; {\n    e.preventDefault();\n    console.log(\"Submitted email:\", email);\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input\n        type=\"email\"\n        value={email}\n        onChange={(e) =&gt; setEmail(e.target.value)}\n      /&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> <ul> <li>React is the single source of truth for the input.</li> <li>Useful for validation, formatting, or conditional rendering.</li> </ul> Tip <ul> <li>\ud83d\udfe2 React controls the input.</li> <li>\ud83d\udfe2 State is the single source of truth.</li> <li>\ud83d\udfe2 Easy to validate, format, and manipulate data dynamically.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#uncontrolled-form-component","title":"\u274c Uncontrolled Form Component","text":"<p>An uncontrolled component is one where the form input keeps its own internal state, and you access its value using a <code>ref</code>.</p> <pre><code>function UncontrolledForm() {\n  const emailRef = useRef();\n\n  const handleSubmit = (e) =&gt; {\n    e.preventDefault();\n    console.log(\"Submitted email:\", emailRef.current.value);\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input type=\"email\" ref={emailRef} /&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> <ul> <li>The DOM maintains the input's value.</li> <li>Good for simple forms or when you don\u2019t need React to track state.</li> </ul> Note <ul> <li>\ud83d\udd35 React does not control the input.</li> <li>\ud83d\udd35 Good for quick or simple forms.</li> <li>\ud83d\udd35 Harder to perform validation or pre-fill logic.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#feature-comparison-table","title":"\ud83d\udcdd Feature Comparison Table","text":"Feature Controlled Uncontrolled State Management React state DOM via <code>ref</code> Value Binding <code>value</code> + <code>onChange</code> <code>defaultValue</code> Validation Easy Requires manual handling Real-time Feedback \u2705 \u274c Resetting Form Update state Use DOM manipulation Initial Values Set via state Use <code>defaultValue</code> prop Use Case Dynamic, interactive forms Simple, static forms","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#when-to-use-which","title":"\ud83e\udded When to Use Which?","text":"Scenario Use Controlled Use Uncontrolled Real-time validation needed \u2705 \u274c Pre-fill values dynamically \u2705 \u274c Simple, static form \u274c \u2705 Form input must be synced with React state \u2705 \u274c Minimal logic on form fields \u274c \u2705 Input behavior or formatting must be customized \u2705 \u274c Performance critical (many uncontrolled fields) \u274c \u2705 Third-party integration / uncontrolled data \u274c \u2705 \u2705 Use Controlled Components When: <ul> <li>You need tight control over form input values.</li> <li>You want to validate or transform input as users type.</li> <li>You're working with dynamic forms (fields show/hide, change rules).</li> <li>You need to sync input values with state, props, or other logic.</li> </ul> \ud83d\udd35 Use Uncontrolled Components When: <ul> <li>You need a quick and simple form.</li> <li>You're building a form that submits once and forgets.</li> <li>You prefer working with refs and DOM elements directly.</li> <li>You don\u2019t need to interact with the form data until submission.</li> <li>Performance is more important than flexibility (e.g., large forms).</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#bonus-hybrid-forms","title":"\ud83e\udde9 Bonus: Hybrid Forms","text":"<p>Some forms use a hybrid approach, combining both controlled and uncontrolled inputs depending on the field.</p> <p>Example: Use controlled inputs for fields with validation, and uncontrolled for optional fields where performance is a concern.</p>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#conclusion","title":"\ud83c\udfaf Conclusion","text":"<ul> <li> <p>Use controlled components for flexibility, validation, and real-time interactivity.</p> </li> <li> <p>Use uncontrolled components for simplicity and performance when you don't need to interact with the input until submission.</p> </li> <li> <p>Understanding when to use each helps you build cleaner, more maintainable forms in React.</p> </li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/","title":"\ud83e\uddea Testing in React: Vitest, Jest &amp; React Testing Library Explained","text":"","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#testing-in-react-vitest-jest-react-testing-library-explained","title":"\ud83e\uddea Testing in React: Vitest, Jest &amp; React Testing Library Explained","text":"<p>Testing in modern React apps can be confusing when you're not sure which tool does what. This blog post explains the roles of Vitest, Jest, and React Testing Library (RTL) \u2014 and how to use them effectively for unit testing, logic, and UI behavior.</p> <p>Both Vitest and Jest are JavaScript testing frameworks, mainly used for unit and integration testing.</p> Success <ul> <li>Vitest/Jest = The test runners.</li> <li>React Testing Library = Library to test React component behavior.</li> <li>You often use both together to test React apps effectively.</li> </ul> <p>To test logic, functions, unit tests, async code, etc., you mainly use Vitest or Jest \u2014 not React Testing Library, since RTL is focused on React UI behavior.</p>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#whats-the-difference","title":"\ud83d\udd0d What's the Difference?","text":"<p>Vitest vs Jest</p> Feature Vitest Jest Test runner \u2705 Yes \u2705 Yes Speed \ud83d\ude80 Fast with Vite \ud83d\udc22 Slower for large projects TypeScript support \ud83e\udde0 Excellent \u2705 Good Vite Integration \ud83d\udd25 Built-in \u274c Manual setup required Community/Ecosystem \ud83c\udf31 Growing \ud83c\udf33 Mature <p>Use Vitest for Vite-based projects, and Jest for broader or legacy setups.</p>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#what-does-react-testing-library-do","title":"\ud83e\uddea What Does React Testing Library Do?","text":"<p>React Testing Library does not run tests \u2014 it helps you test how users interact with the UI.</p> <p>You can use RTL with either Vitest or Jest. It focuses on:</p> <ul> <li>Rendering components</li> <li>Querying DOM elements</li> <li>Simulating user actions</li> <li>Verifying visible behavior</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#testing-examples","title":"\ud83d\udee0\ufe0f Testing Examples","text":"","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#1-testing-logic-unit-test","title":"\u2705 1. Testing Logic (Unit Test)","text":"<pre><code>// utils/calc.js\nexport function add(a, b) {\n  return a + b;\n}\n</code></pre> <pre><code>// calc.test.js\nimport { describe, it, expect } from \"vitest\";\nimport { add } from \"./calc\";\n\ndescribe(\"add\", () =&gt; {\n  it(\"adds two numbers\", () =&gt; {\n    expect(add(2, 3)).toBe(5);\n  });\n});\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#2-testing-async-functions-like-api-calls-or-timers","title":"\u2705 2. Testing Async Functions (like API calls or timers)","text":"<pre><code>// utils/fetchData.js\nexport async function fetchData() {\n  const res = await fetch(\"/api/data\");\n  return res.json();\n}\n</code></pre> <pre><code>// fetchData.test.js\nimport { vi, describe, it, expect } from \"vitest\";\n\nglobal.fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    json: () =&gt; Promise.resolve({ name: \"Test\" }),\n  })\n);\n\nimport { fetchData } from \"./fetchData\";\n\ndescribe(\"fetchData\", () =&gt; {\n  it(\"returns mocked data\", async () =&gt; {\n    const data = await fetchData();\n    expect(data).toEqual({ name: \"Test\" });\n  });\n});\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#3-testing-react-component-ui","title":"\u2705 3. Testing React Component (UI)","text":"<pre><code>// MyComponent.jsx\nexport default function MyComponent() {\n  return &lt;h1&gt;Hello World&lt;/h1&gt;;\n}\n</code></pre> <pre><code>// MyComponent.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { describe, it, expect } from \"vitest\";\nimport MyComponent from \"./MyComponent\";\n\ndescribe(\"MyComponent\", () =&gt; {\n  it(\"renders a message\", () =&gt; {\n    render(&lt;MyComponent /&gt;);\n    expect(screen.getByText(/hello world/i)).toBeInTheDocument();\n  });\n});\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#testing-logic-inside-react-components","title":"\u2705 Testing Logic Inside React Components","text":"<p>You still use Vitest, but for logic-only parts (e.g., utility functions, custom hooks, state management functions), you don\u2019t need React Testing Library.</p> <p>Example: Testing a custom hook</p> <pre><code>// hooks/useCounter.js\nimport { useState } from \"react\";\n\nexport function useCounter() {\n  const [count, setCount] = useState(0);\n  const increment = () =&gt; setCount((c) =&gt; c + 1);\n  return { count, increment };\n}\n</code></pre> <pre><code>// hooks/useCounter.test.js\nimport { renderHook, act } from \"@testing-library/react\";\nimport { useCounter } from \"./useCounter\";\n\ndescribe(\"useCounter\", () =&gt; {\n  it(\"increments the counter\", () =&gt; {\n    const { result } = renderHook(() =&gt; useCounter());\n    act(() =&gt; {\n      result.current.increment();\n    });\n    expect(result.current.count).toBe(1);\n  });\n});\n</code></pre> <p>\ud83d\udee0\ufe0f <code>renderHook</code> is part of<code>@testing-library/react-hooks</code> or comes from the main RTL in newer versions.</p>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#summary","title":"\ud83c\udfaf Summary","text":"Test Type Tool(s) Purpose Unit tests Vitest / Jest Pure logic, math, utilities Async functions Vitest / Jest API calls, async logic UI components Vitest / Jest + RTL React rendering and behavior Custom Hooks RTL <code>renderHook</code> + Vitest Hook logic, state behavior <p>&amp;</p> Type of Test Tools Used Example Pure Logic Vitest / Jest Math functions, string utilities Async Code Vitest / Jest + <code>vi.mock</code> API calls, delays Component UI Vitest / Jest + RTL Rendering, user interaction Custom Hooks RTL <code>renderHook</code> + Vitest State logic in hooks","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#final-thoughts","title":"\ud83d\udd1a Final Thoughts","text":"<p>Use Vitest if you're using Vite. Use Jest if you're not. Use React Testing Library to test what the user sees and does. Together, they help you write confident, maintainable, and effective tests for your React app.</p>","tags":["Personal"]},{"location":"jest/overview/","title":"Overview","text":""},{"location":"jest/overview/#overview","title":"Overview","text":""},{"location":"jest/overview/#reference","title":"Reference","text":"<ul> <li>Linkedin: Vitest vs Jest: A Personal Take on Testing Frameworks</li> <li>Medium: Vitest: Unleashing the Next Generation of Testing Frameworks</li> <li>Medium: Setup Vite2 with Vitest &amp; Jest for testing in react app</li> </ul>"},{"location":"jest/refactoring-strategy/","title":"Refactoring Strategy","text":""},{"location":"jest/refactoring-strategy/#refactoring-strategy","title":"Refactoring strategy","text":"<p>Here's a practical and realistic testing + refactoring strategy tailored for your React 18 + Ant Design + RTK Query + Axios app. The goal is to:</p> <ul> <li>Test existing code (test-last) \u2705</li> <li>Refactor safely \ud83d\udee0</li> <li>Gradually improve maintainability \ud83d\udd01</li> </ul>"},{"location":"jest/refactoring-strategy/#overall-strategy-overview","title":"\ud83e\udded Overall Strategy Overview","text":""},{"location":"jest/refactoring-strategy/#phase-1-foundation-set-up-small-wins","title":"\ud83e\uddf1 Phase 1: Foundation \u2013 Set Up &amp; Small Wins","text":"<p>Goal: Get testing infrastructure and habits in place.</p> <p>\u2705 Step 1: Install and Configure Testing Tools</p> <ul> <li><code>@testing-library/react</code></li> <li><code>jest</code> (or vitest if using Vite)</li> <li><code>@testing-library/jest-dom</code></li> <li>[Optional] <code>msw</code> (Mock Service Worker) for mocking API responses</li> </ul> <p>\u2705 Step 2: Smoke Test Existing Components</p> <p>Pick 2\u20133 components to start with. Add minimal tests:</p> <ul> <li>Does the component render?</li> <li>Does it show loading/error states?</li> <li>Can it display mock data?</li> </ul> <p>Keep it low-effort to get coverage started.</p>"},{"location":"jest/refactoring-strategy/#phase-2-isolate-logic-from-ui","title":"\ud83e\udde9 Phase 2: Isolate Logic from UI","text":"<p>Goal: Refactor code to make it easier to test.</p> <p>\ud83e\uddea Strategy A: Separate Business Logic from Presentation</p> <p>Example:</p> <p>Extract RTK Query logic into a custom hook.</p> <pre><code>// hooks/useUsers.js\nimport { useGetUsersQuery } from \"../store/api\";\n\nexport const useUsers = () =&gt; {\n  return useGetUsersQuery();\n};\n</code></pre> <p>Now test the hook separately if needed using <code>@testing-library/react-hooks</code>.</p> <p>\ud83e\uddea Strategy B: Extract Complex UI into Reusable Components</p> <p>If a component is doing too much:</p> <ul> <li>Fetching data</li> <li>Showing table</li> <li>Handling pagination or modals</li> </ul> <p>Split it into:</p> <ul> <li><code>UsersTable</code> (UI only)</li> <li><code>UsersContainer</code> (data fetching)</li> </ul>"},{"location":"jest/refactoring-strategy/#phase-3-create-targeted-test-suites","title":"\ud83d\udd01 Phase 3: Create Targeted Test Suites","text":"<p>Goal: Increase test confidence in key areas.</p> <p>\ud83d\udd0d Prioritize These:</p> <ul> <li>Components with critical workflows (e.g., login, checkout, user update)</li> <li>Anything connected to state management or API</li> <li>Components using AntD modals, forms, or tables, since those are easy to break with refactors</li> </ul> <p>\ud83c\udfaf Test Types to Include:</p> <ul> <li>Behavioral tests (user interaction + what user sees)</li> <li>Error states (API failures)</li> <li>Conditional rendering (modals, loading, permissions)</li> </ul>"},{"location":"jest/refactoring-strategy/#phase-4-replace-axios-where-possible-with-rtk-query","title":"\ud83e\uddea Phase 4: Replace <code>axios</code> Where Possible with RTK Query","text":"<p>If you're still using <code>axios</code> in parts:</p> <ul> <li>Migrate API logic to RTK Query</li> <li>This improves standardization, caching, and testability</li> </ul> <p>You can test RTK Query logic using MSW to mock endpoints.</p> <p>\ud83d\udd28 Example Refactoring + Testing Use Case</p> <p>\ud83d\udd01 Original:</p> <pre><code>useEffect(() =&gt; {\n  axios.get(\"/api/users\").then(setUsers);\n}, []);\n</code></pre> <p>\u2705 Refactored with RTK:</p> <pre><code>// store/api.js\nconst usersApi = createApi({ ... });\nexport const useGetUsersQuery = usersApi.endpoints.getUsers.useQuery;\n</code></pre> <p>\ud83e\uddea Test With Mock:</p> <pre><code>test(\"shows users after loading\", async () =&gt; {\n  server.use(\n    rest.get(\"/api/users\", (req, res, ctx) =&gt;\n      res(ctx.json([{ id: 1, name: \"Alice\" }]))\n    )\n  );\n\n  render(&lt;UserList /&gt;);\n  expect(await screen.findByText(\"Alice\")).toBeInTheDocument();\n});\n</code></pre> <p>\u2705 Summary: Your React Refactor/Test Strategy</p> Phase Goal Actions 1. Foundation Enable testing, write minimal tests Set up Jest + RTL, smoke tests 2. Isolate Logic Make code testable Extract hooks, split smart/dumb components 3. Prioritize Focus on critical areas Target RTK Query, forms, modals, key workflows 4. Migrate Remove legacy patterns Replace axios with RTK Query where possible 5. Harden Add interaction + edge tests Use MSW, test loading/error/success paths"},{"location":"tdd/approach/","title":"Approach","text":""},{"location":"tdd/approach/#approach","title":"Approach","text":"\ud83d\udcd8 Uncle Bob's Advice on This <p>Uncle Bob strongly supports writing tests before refactoring, even in test-last scenarios:</p> <pre><code>&gt; \"You cannot refactor without tests. If you try, you are just changing code blindly and hoping it still works.\"\n\u2014Robert C. Martin\n</code></pre> <p>His book \u201cWorking Effectively with Legacy Code\u201d (by Michael Feathers, which he endorses) emphasizes this strategy heavily.</p>"},{"location":"tdd/approach/#quick-guidelines","title":"\ud83e\udde0 Quick Guidelines","text":"Refactoring Scenario Suggested Testing Approach Code already exists \u2705 Characterization tests (Test-Last) New functionality \u2705 Use Test-First (TDD) Unknown behavior / bugs \ud83d\udd75\ufe0f Add tests to lock current behavior High-risk change \ud83d\udee1 Add integration/system-level tests"},{"location":"tdd/approach/#uncle-bob-on-test-first-vs-test-last","title":"\ud83d\udee0\ufe0f Uncle\u202fBob on Test-First vs Test-Last","text":""},{"location":"tdd/approach/#test-first-tdd-proper","title":"\u2705 Test-First (TDD proper)","text":"<ul> <li> <p>Red/Green/Refactor cycle: write a failing test, then code to pass it, then refactor\u2014following the Three Laws.</p> </li> <li> <p>Treats tests as executable specifications. They guide the code design and drive modular, decoupled architecture.</p> </li> <li> <p>Emphasis on keeping tests F.I.R.S.T (Fast, Independent, Repeatable, Self-validating, Timely) to maintain rapid feedback.</p> </li> <li> <p>Encourages outside-in design using test doubles (London style) to mock slow parts and focus design.</p> </li> <li> <p>Transformation Priority Premise helps choose simple transformations first, making the implementation process clearer.</p> </li> </ul> Occurs: <p>Before writing any implementation code.</p> <p>Steps:</p> <ol> <li>Write a failing test \u2014 Describe the expected behavior or output of a component or function.</li> <li>Run the test \u2014 Confirm that it fails (this ensures the test is valid).</li> <li>Write the minimal code \u2014 Implement just enough to make the test pass.</li> <li>Run the test again \u2014 It should now pass.</li> <li>Refactor \u2014 Clean up the code while keeping tests green.</li> </ol> Example<pre><code>// Test (written first)\ntest('Button displays correct label', () =&gt; {\n    render(&lt;Button label=\"Click me\" /&gt;);\n    expect(screen.getByText('Click me')).toBeInTheDocument();\n});\n</code></pre>"},{"location":"tdd/approach/#test-last-not-tdd","title":"\ud83e\uddea Test-Last (not TDD)","text":"<ul> <li> <p>You write the bulk of production code first; tests come later.</p> </li> <li> <p>Less guidance; code may evolve without early constraints, possibly leading to tightly coupled or untestable designs.</p> </li> <li> <p>Easier to slip into without discipline, but risking long build times and lower test coverage.</p> </li> <li> <p>Tends to miss the benefits of early abstraction, clean architecture, and design-for-testability.</p> </li> </ul> Occurs: <p>After writing implementation code.</p> <ul> <li>You write a component or function first.</li> <li>Then, you write tests to cover what you've already implemented.</li> <li>This is not TDD, but still a form of testing (often called test-after or test-last development).</li> </ul> <ul> <li>\ud83d\udeab Not TDD, but better than no tests.</li> <li>\u2705 Can be useful during legacy refactoring or prototyping.</li> </ul>"},{"location":"tdd/approach/#which-approach-should-you-choose","title":"\ud83d\udca1 Which Approach Should You Choose?","text":"Scenario Recommendation Why Want cleaner design &amp; rapid refactoring Test\u2011First (TDD) Acts as built-in spec, encourages testable, modular code, and keeps cycle tight and safe. Working under time pressure or on exploratory code Test\u2011Last (with caution) Offers faster progress but risks technical debt and brittle code if tests delayed too long. Maintaining existing legacy code Hybrid Add tests where needed, but gradually adopt TDD for new features. User-facing behavior / system flow Use BDD/ATDD Write high-level tests first (e.g. Gherkin), then implement with TDD under the hood ([blog.cleancoder.com][1], [cleancoders.com][2], [arxiv.org][3])."},{"location":"tdd/approach/#summary","title":"Summary","text":"Approach Test-First TDD Test-Last When tests are written Before implementation code After implementation code Driving factor Tests drive the design Code drives the tests Typical in TDD? \u2705 Yes \u274c No"},{"location":"tdd/approach/#final-thoughts","title":"\u2705 Final Thoughts","text":"<ul> <li> <p>Prefer Test-First/TDD for most development\u2014especially if quality, refactoring, and long-term agility matter.</p> </li> <li> <p>If you must go Test-Last, ensure you maintain:</p> </li> <li> <p>Incremental cycles (small commits)</p> </li> <li>Timely testing right after feature implementation</li> <li>Commitment to test enforceability\u2014no backlog of untested code.</li> </ul> <p>Uncle\u202fBob\u2019s central message: tests aren\u2019t just validation\u2014they\u2019re design tools. Use them early and often to shape better code.</p>"},{"location":"tdd/characterization-testing/","title":"Characterization Testing","text":""},{"location":"tdd/characterization-testing/#characterization-testing","title":"Characterization Testing","text":"<p>The answer depends on the team's workflow, but in most modern software practices \u2014 especially when working with legacy code or during refactoring \u2014 the responsibility usually falls on the:</p>"},{"location":"tdd/characterization-testing/#developer-most-of-the-time","title":"\u2705 Developer (most of the time)","text":"<p>Why?</p> <ul> <li>Characterization tests are code-based: they require writing unit, integration, or UI tests in code to \u201clock in\u201d behavior.</li> <li>Developers are the ones doing the refactoring, so they need a safety net (tests) to know they haven\u2019t broken anything.</li> <li>In legacy systems, developers often don\u2019t have good documentation \u2014 the tests become their source of truth.</li> </ul> <p>Typical Activities:</p> <ul> <li>Interact with the app or API</li> <li>Observe behavior manually (or via logs, tools)</li> <li>Reproduce it in a test file (<code>*.test.js</code>, <code>*.spec.ts</code>, etc.)</li> <li>Then refactor safely</li> </ul>"},{"location":"tdd/characterization-testing/#qa-may-also-be-involved-but-differently","title":"\ud83d\udc69\u200d\ud83d\udd2c QA May Also Be Involved (but differently)","text":"<p>When QA helps:</p> <ul> <li> <p>In BDD/ATDD environments, QA may help define expected behaviors using tools like Cucumber (e.g. Gherkin syntax).</p> </li> <li> <p>QA can report behavior that differs from expected \u2014 this is super useful when developers aren\u2019t sure if behavior is correct or just legacy quirk.</p> </li> <li> <p>In manual testing, QA may record how the app behaves during specific scenarios. Devs can use these as the basis for tests.</p> </li> </ul>"},{"location":"tdd/characterization-testing/#a-simple-rule-of-thumb","title":"\ud83e\udde0 A Simple Rule of Thumb","text":"Task Developer QA Writing characterization tests \u2705 Yes \u274c Not usually Recording user-visible behavior \u2705 Often \u2705 Also possible Defining correct business behavior \u2705 Sometimes \u2705 Often (especially in ATDD/BDD) Manual behavior verification \ud83d\udd04 Shared \u2705 Primary role"},{"location":"tdd/characterization-testing/#final-thought","title":"\ud83c\udfaf Final Thought","text":"<p>Developers write the characterization tests,</p> <p>QA helps define or verify behavior \u2014 especially when correctness is in question.</p>"},{"location":"tdd/example/","title":"Example","text":""},{"location":"tdd/example/#example","title":"Example","text":"<p>Here\u2019s a complete folder structure example for a real-world React + TDD-ready project using:</p> <ul> <li>\u2705 Vitest (or Jest)</li> <li>\u2705 React Testing Library</li> <li>\u2705 MSW (for mocking APIs)</li> <li>\u2705 Cypress (for end-to-end testing)</li> </ul>"},{"location":"tdd/example/#overview","title":"Overview","text":""},{"location":"tdd/example/#project-layout-example-hybrid-tdd-structure","title":"\ud83d\udce6 Project Layout Example (Hybrid TDD Structure)","text":"<pre><code>my-app/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 Button/\n\u2502   \u2502       \u251c\u2500\u2500 Button.tsx\n\u2502   \u2502       \u251c\u2500\u2500 Button.test.tsx          # \u2705 Unit/component test\n\u2502   \u2502       \u2514\u2500\u2500 Button.types.ts\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.ts\n\u2502   \u2502   \u2514\u2500\u2500 useAuth.test.ts              # \u2705 Hook unit/integration test\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u2502   \u2514\u2500\u2500 auth/\n\u2502   \u2502       \u251c\u2500\u2500 LoginForm.tsx\n\u2502   \u2502       \u251c\u2500\u2500 LoginForm.test.tsx       # \u2705 Component test\n\u2502   \u2502       \u251c\u2500\u2500 authSlice.ts             # Redux slice\n\u2502   \u2502       \u251c\u2500\u2500 authSlice.test.ts        # \u2705 Pure logic test\n\u2502   \u2502       \u2514\u2500\u2500 api.ts                   # RTK Query or Axios logic\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2502   \u251c\u2500\u2500 validators.ts\n\u2502   \u2502   \u2514\u2500\u2500 validators.test.ts           # \u2705 Pure function test\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.tsx\n\u2502   \u2514\u2500\u2500 main.tsx\n\u2502\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2502   \u2514\u2500\u2500 loginFlow.test.tsx          # \u2705 TDD integration test\n\u2502   \u2514\u2500\u2500 e2e/\n\u2502       \u2514\u2500\u2500 login.cy.ts                 # \u2705 E2E with Cypress\n\u2502\n\u251c\u2500\u2500 cypress/\n\u2502   \u251c\u2500\u2500 support/\n\u2502   \u2502   \u2514\u2500\u2500 commands.ts\n\u2502   \u2514\u2500\u2500 fixtures/\n\u2502       \u2514\u2500\u2500 user.json\n\u2502\n\u251c\u2500\u2500 mocks/\n\u2502   \u251c\u2500\u2500 handlers.ts                     # MSW API mocks\n\u2502   \u2514\u2500\u2500 server.ts\n\u2502\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 tsconfig.json\n\u251c\u2500\u2500 vite.config.ts                     # Or use Webpack config\n\u251c\u2500\u2500 vitest.config.ts                   # For unit/integration testing\n\u251c\u2500\u2500 cypress.config.ts\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"tdd/example/#test-types-placement-why-this-works","title":"\ud83e\uddea Test Types Placement (Why This Works)","text":"Folder/File Purpose <code>Button.test.tsx</code> Unit test for button UI behavior <code>useAuth.test.ts</code> Integration test for hook + state <code>authSlice.test.ts</code> Pure reducer test (Chicago-style TDD) <code>loginFlow.test.tsx</code> Integration: form submit + API mock <code>login.cy.ts</code> Full E2E flow with real browser <code>mocks/</code> API mocking (e.g., MSW for Vitest)"},{"location":"tdd/example/#sample-test-buttontesttsx","title":"\ud83e\uddea Sample Test: <code>Button.test.tsx</code>","text":"<pre><code>import { render, screen, fireEvent } from \"@testing-library/react\";\nimport Button from \"./Button\";\n\ntest(\"calls onClick when clicked\", () =&gt; {\n  const onClick = vi.fn(); // or jest.fn() with Jest\n  render(&lt;Button onClick={onClick}&gt;Click me&lt;/Button&gt;);\n  fireEvent.click(screen.getByText(/click me/i));\n  expect(onClick).toHaveBeenCalledTimes(1);\n});\n</code></pre>"},{"location":"tdd/example/#sample-test-loginflowtesttsx","title":"\ud83e\uddea Sample Test: <code>loginFlow.test.tsx</code>","text":"<pre><code>import { render, screen, fireEvent } from \"@testing-library/react\";\nimport { rest } from \"msw\";\nimport { setupServer } from \"msw/node\";\nimport LoginForm from \"@/features/auth/LoginForm\";\n\nconst server = setupServer(\n  rest.post(\"/api/login\", (req, res, ctx) =&gt; {\n    return res(ctx.status(200), ctx.json({ token: \"123\" }));\n  })\n);\n\nbeforeAll(() =&gt; server.listen());\nafterEach(() =&gt; server.resetHandlers());\nafterAll(() =&gt; server.close());\n\ntest(\"logs in user successfully\", async () =&gt; {\n  render(&lt;LoginForm /&gt;);\n  fireEvent.change(screen.getByLabelText(/email/i), {\n    target: { value: \"test@example.com\" },\n  });\n  fireEvent.change(screen.getByLabelText(/password/i), {\n    target: { value: \"password123\" },\n  });\n  fireEvent.click(screen.getByRole(\"button\", { name: /login/i }));\n\n  const successMsg = await screen.findByText(/welcome/i);\n  expect(successMsg).toBeInTheDocument();\n});\n</code></pre>"},{"location":"tdd/example/#sample-cypress-test-logincyts","title":"\ud83e\uddea Sample Cypress Test: <code>login.cy.ts</code>","text":"<pre><code>describe(\"Login Flow\", () =&gt; {\n  it(\"allows user to log in\", () =&gt; {\n    cy.visit(\"/login\");\n    cy.get(\"input[name=email]\").type(\"test@example.com\");\n    cy.get(\"input[name=password]\").type(\"password123\");\n    cy.get(\"button\").contains(\"Login\").click();\n    cy.contains(\"Welcome, test@example.com\").should(\"be.visible\");\n  });\n});\n</code></pre>"},{"location":"tdd/folder-structure/","title":"Folder Structure","text":""},{"location":"tdd/folder-structure/#folder-structure","title":"Folder Structure","text":"<p>Here\u2019s a minimal file structure for a React app using TDD, commonly seen in real-world production codebases.</p>"},{"location":"tdd/folder-structure/#overview","title":"Overview","text":""},{"location":"tdd/folder-structure/#tdd-friendly-react-project-structure","title":"\u2705 TDD-Friendly React Project Structure","text":"<pre><code>my-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 Button/\n\u2502   \u2502       \u251c\u2500\u2500 Button.tsx\n\u2502   \u2502       \u251c\u2500\u2500 Button.test.tsx          # \ud83e\uddea Component-level TDD\n\u2502   \u2502       \u2514\u2500\u2500 Button.types.ts\n\u2502\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u2514\u2500\u2500 useAuth.ts\n\u2502   \u2502   \u2514\u2500\u2500 useAuth.test.ts              # \ud83e\uddea Unit + Integration TDD for hooks\n\u2502\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u2502   \u2514\u2500\u2500 auth/\n\u2502   \u2502       \u251c\u2500\u2500 LoginForm.tsx\n\u2502   \u2502       \u251c\u2500\u2500 LoginForm.test.tsx       # \ud83e\uddea Component TDD (form behavior)\n\u2502   \u2502       \u251c\u2500\u2500 authSlice.ts             # Redux logic (RTK)\n\u2502   \u2502       \u251c\u2500\u2500 authSlice.test.ts        # \ud83e\uddea Chicago-style unit test\n\u2502   \u2502       \u2514\u2500\u2500 api.ts                   # RTK Query or Axios calls\n\u2502\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2502   \u251c\u2500\u2500 validators.ts\n\u2502   \u2502   \u2514\u2500\u2500 validators.test.ts           # \ud83e\uddea Pure unit test (no DOM)\n\u2502\n\u2502   \u251c\u2500\u2500 App.tsx\n\u2502   \u2514\u2500\u2500 main.tsx\n\u2502\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2502   \u2514\u2500\u2500 loginFlow.test.tsx          # \ud83e\uddea Integration TDD (Login + Redux + API)\n\u2502   \u2514\u2500\u2500 e2e/\n\u2502       \u2514\u2500\u2500 login.cy.ts                 # \u2705 ATDD / E2E tests using Cypress or Playwright\n\u2502\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tsconfig.json\n\u251c\u2500\u2500 jest.config.ts\n\u2514\u2500\u2500 vitest.config.ts                    # or jest.config.js depending on stack\n</code></pre>"},{"location":"tdd/folder-structure/#directory-overview-best-practices","title":"\ud83d\udcc2 Directory Overview &amp; Best Practices","text":"Folder/File Description <code>components/</code> Isolated UI elements (Button, Modal). TDD focuses on props and DOM interaction. <code>hooks/</code> Custom hooks (useForm, useAuth). TDD helps with async flows, state management. <code>features/</code> Feature-based organization. Good for large apps. Keeps logic + UI close. <code>utils/</code> Reusable logic. Pure unit testing (no mocks, no DOM). <code>tests/integration/</code> Test full flows: user fills form \u279d dispatch \u279d result shows. <code>tests/e2e/</code> Simulate real browser user using Playwright or Cypress. Best for ATDD."},{"location":"tdd/folder-structure/#tool-stack-for-tdd","title":"\ud83e\uddea Tool Stack for TDD","text":"Purpose Tools Unit Testing Jest / Vitest React Component Testing React Testing Library API Mocking MSW (Mock Service Worker) End-to-End Testing Cypress / Playwright Coverage <code>--coverage</code> with Jest/Vitest"},{"location":"tdd/folder-structure/#example-button-tdd","title":"\u2705 Example: Button TDD","text":"<pre><code>import { render, screen, fireEvent } from \"@testing-library/react\";\nimport Button from \"./Button\";\n\ntest(\"calls onClick when clicked\", () =&gt; {\n  const handleClick = vi.fn(); // or jest.fn() if using Jest\n  render(&lt;Button onClick={handleClick}&gt;Click me&lt;/Button&gt;);\n  fireEvent.click(screen.getByText(\"Click me\"));\n  expect(handleClick).toHaveBeenCalled();\n});\n</code></pre> <p>Let me know if you want:</p> <ul> <li>A working GitHub boilerplate repo</li> <li>CI/CD setup with test runners</li> <li>Example of MSW + RTK Query tests</li> <li>Cypress or Playwright login flow test</li> </ul>"},{"location":"tdd/folder-structure/#types-of-folder-structure","title":"Types of Folder Structure","text":"<p>In real-world applications \u2014 especially with React, Node.js, or full-stack apps \u2014 there are three common folder structures for tests:</p>"},{"location":"tdd/folder-structure/#1-colocated-feature-based-structure","title":"\ud83c\udfd7\ufe0f 1. Colocated (Feature-Based) Structure","text":"<p>Tests live next to the components, hooks, or modules they test.</p> <p>\u2705 Very common in modern React &amp; frontend apps.</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 Button/\n\u2502       \u251c\u2500\u2500 Button.tsx\n\u2502       \u251c\u2500\u2500 Button.test.tsx     \u2190 \ud83d\udccc test next to code\n\u2502       \u2514\u2500\u2500 Button.styles.ts\n\u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 useAuth.ts\n\u2502   \u2514\u2500\u2500 useAuth.test.ts         \u2190 \ud83d\udccc colocated test\n</code></pre> <p>\ud83d\udd25 Pros:</p> <ul> <li>Easier to find &amp; maintain</li> <li>Encourages testing each unit as it's built (TDD-style)</li> <li>Good for smaller/medium apps</li> </ul> <p>\u26a0\ufe0f Cons:</p> <ul> <li>Scattered when searching for all tests</li> <li>Harder to separate unit vs integration vs e2e at a glance</li> </ul>"},{"location":"tdd/folder-structure/#2-dedicated-tests-or-__tests__-folder","title":"\ud83c\udfd7\ufe0f 2. Dedicated <code>/tests</code> or <code>/__tests__</code> Folder","text":"<p>All test files live in a centralized test folder (sometimes mirrored structure).</p> <p>\u2705 Common in larger teams or CI-heavy setups.</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 Button.tsx\ntests/\n\u251c\u2500\u2500 unit/\n\u2502   \u2514\u2500\u2500 components/\n\u2502       \u2514\u2500\u2500 Button.test.tsx\n\u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 loginFlow.test.tsx\n</code></pre> <p>\ud83d\udd25 Pros:</p> <ul> <li>Easy to locate all tests</li> <li>Clean separation of source vs test logic</li> <li>Good for testing dashboards, services, and full features</li> </ul> <p>\u26a0\ufe0f Cons:</p> <ul> <li>Extra effort to keep file paths in sync</li> <li>Higher friction in TDD workflow</li> </ul>"},{"location":"tdd/folder-structure/#3-hybrid-structure-colocated-centralized-integratione2e","title":"\ud83c\udfd7\ufe0f 3. Hybrid Structure (Colocated + Centralized Integration/E2E)","text":"<p>Most real-world apps end up doing this:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 Button/\n\u2502       \u251c\u2500\u2500 Button.tsx\n\u2502       \u2514\u2500\u2500 Button.test.tsx        \u2190 \u2705 colocated unit/component test\ntests/\n\u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 authFlow.test.tsx          \u2190 \u2705 feature-level test\n\u251c\u2500\u2500 e2e/\n\u2502   \u2514\u2500\u2500 login.cy.ts                \u2190 \u2705 end-to-end with Cypress\n</code></pre> <p>\ud83d\udd25 Pros:</p> <ul> <li>Best of both worlds</li> <li>Unit tests stay near the logic</li> <li>High-level flows are tested separately and organized clearly</li> <li>Works great with monorepos and micro-frontends</li> </ul> <p>\u26a0\ufe0f Cons:</p> <ul> <li>Slight learning curve</li> <li>Requires team convention enforcement</li> </ul>"},{"location":"tdd/folder-structure/#best-practice-by-test-type","title":"\ud83e\uddea Best Practice by Test Type","text":"Test Type Suggested Folder Unit Test <code>src/components/Button/Button.test.tsx</code> (colocated) Hook Test <code>src/hooks/useForm.test.ts</code> Redux/Logic Test <code>src/features/auth/authSlice.test.ts</code> Integration Test <code>tests/integration/featureFlow.test.tsx</code> E2E Test <code>tests/e2e/login.cy.ts</code>"},{"location":"tdd/folder-structure/#recommendation-for-most-projects","title":"\u2705 Recommendation for Most Projects","text":"<pre><code># Example: hybrid layout\nsrc/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 Button/Button.test.tsx       # unit/component\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useFetch/useFetch.test.ts    # hook\ntests/\n\u251c\u2500\u2500 integration/userSignup.test.tsx  # feature flow\n\u251c\u2500\u2500 e2e/signup.cy.ts                 # end-to-end (Cypress/Playwright)\n</code></pre>"},{"location":"tdd/overview/","title":"Overview","text":""},{"location":"tdd/overview/#overview","title":"Overview","text":"<p>TDD is a software development methodology in which tests are written to drive the development of an application. It was developed/rediscovered by Kent Beck in the late 1990s as part of Extreme Programming1 and was well discussed in his famous book Test-Driven Development. (1)</p> <ol> <li> <p>Test-Driven Development With React and Typescript</p> </li> <li> <p>Extreme Programming, Martin fowler</p> </li> </ol> <p>In his book, Kent Beck describes two essential rules:</p> <ul> <li>Write new code only if you first have a failing automated test</li> <li>Eliminate duplication</li> </ul> <p>which leads to the steps of Red-Green-Refactor, which we will discuss soon. The ultimate goal for these two rules is to write (as Ron Jeffries describes) clean code that works.</p>"},{"location":"tdd/overview/#the-red-green-refactor-cycle","title":"The Red-Green-Refactor Cycle","text":"<p>Red-Green-Refactor is the core cycle of Test-Driven Development (TDD) methodology. The cycle involves the following steps:</p> <ol> <li> <p>Red: Write a failing test that describes the desired behavior of a specific feature or functionality. The test should not pass yet as the functionality has not yet been implemented.</p> </li> <li> <p>Green: Write the minimum amount of production code necessary to make the failing test pass. The focus should be solely on passing the test, without worrying about code quality or design.</p> </li> <li> <p>Refactor: Improve the design of the production code without changing its behavior, ensuring that all tests continue to pass. This step includes optimizing the code, removing duplication, and enhancing its overall quality.</p> </li> </ol> <p>The cycle repeats with each new feature or functionality, with the goal of producing high-quality code that meets the specified requirements and is maintainable over time. The Red-Green-Refactor cycle (Figure 1-1) emphasizes writing automated tests before writing any production code, ensuring that the code is continually tested and improved as it evolves.</p> <p></p> <p>Traditionally, TDD contains two major parts:</p> <ol> <li>quick implementation &amp;</li> <li>refactoring.</li> </ol> <p>In practice, the tests for quick implementation are not limited to the unit tests. They can be the acceptance tests as well \u2013 these are higher-level tests that focus more on business value and the end-user journey, without worrying too much about the technical details. Implementing the acceptance tests first could be an even better idea.</p> Best Practice for React/JS TDD <ul> <li>Use Jest + React Testing Library or Vitest.</li> <li>Focus on behavior, not implementation details.</li> <li>Stick to test-first when doing TDD.</li> </ul>"},{"location":"tdd/overview/#reference","title":"Reference","text":"<ul> <li>Test-Driven Development with React and TypeScript, Second Edition by Juntao Qiu</li> </ul>"},{"location":"tdd/react-tdd-style/","title":"React TDD Style","text":""},{"location":"tdd/react-tdd-style/#react-tdd-style-guide","title":"React TDD Style Guide","text":"<p>In React applications, the most common and effective TDD style is Chicago-style TDD, also known as Detroit-style. This approach focuses on testing logic, state, and visible behavior without relying heavily on mocks or testing internal implementation details.</p>"},{"location":"tdd/react-tdd-style/#most-common-chicago-style-tdd","title":"\u2705 Most Common: Chicago-Style TDD","text":""},{"location":"tdd/react-tdd-style/#why-its-popular-in-react","title":"\ud83d\udd0d Why it's popular in React","text":"Reason Explanation React favors pure logic Components and hooks are often functional and deterministic \u2014 perfect for input/output testing. Encouraged by React Testing Library RTL promotes testing what the user sees, not implementation details. Minimal mocking Most React logic doesn\u2019t require mocks unless dealing with APIs or services. More maintainable tests Chicago-style tests are less brittle and easier to understand."},{"location":"tdd/react-tdd-style/#example-chicago-style-react-test","title":"\ud83e\uddea Example: Chicago-Style React Test","text":"<pre><code>import { render, screen, fireEvent } from \"@testing-library/react\";\nimport LoginForm from \"./LoginForm\";\n\ntest(\"disables submit when fields are empty\", () =&gt; {\n  render(&lt;LoginForm /&gt;);\n  const button = screen.getByRole(\"button\", { name: /login/i });\n  expect(button).toBeDisabled();\n});\n</code></pre> <ul> <li>\u2705 Tests the behavior, not implementation</li> <li>\u2705 No mocking required</li> <li>\u2705 Reflects actual user interaction</li> </ul>"},{"location":"tdd/react-tdd-style/#recommended-tools-for-chicago-tdd-in-react","title":"\ud83e\uddf0 Recommended Tools for Chicago TDD in React","text":"<ul> <li>React Testing Library \u2013 For testing DOM behavior and interactions</li> <li>Jest \u2013 For test running, assertions, and basic mocking</li> <li>Vitest \u2013 (Optional) Faster alternative to Jest in Vite-based apps</li> </ul>"},{"location":"tdd/react-tdd-style/#other-tdd-styles-in-react-used-less-frequently","title":"\ud83e\udd1d Other TDD Styles in React (Used Less Frequently)","text":"Style When It's Used London Style When isolating external services (e.g., mocking API or auth services) Component TDD When developing reusable, stylized UI components BDD / ATDD In end-to-end testing with Cypress, Playwright, or Gherkin Integration TDD When testing full flows (e.g., login \u2192 dashboard \u2192 profile)"},{"location":"tdd/react-tdd-style/#summary","title":"\ud83e\udde0 Summary","text":"<ul> <li>Chicago-style TDD is the dominant testing style in React for unit and component testing.</li> <li>It aligns with how React encourages component composition and behavior-driven UI.</li> <li>Use other styles (London, BDD, integration) selectively where appropriate.</li> </ul> <p>Test behavior, not implementation. Let the user\u2019s experience guide your tests.</p>"},{"location":"tdd/react-tdd-style/#example","title":"Example","text":"<p>In a React application, Chicago-style TDD focuses on testing the following key areas:</p>"},{"location":"tdd/react-tdd-style/#where-chicago-style-tdd-applies-in-react","title":"\u2705 Where Chicago-Style TDD Applies in React","text":"Layer What It Tests Example \ud83e\udde9 Components DOM output, state, props Button disabled/enabled, input value changes \u2699\ufe0f Hooks State transitions, return values Custom <code>useCounter</code>, <code>useToggle</code> \ud83e\udde0 Pure Functions Logic, formatting, validation <code>formatDate()</code>, <code>calculateTax()</code>"},{"location":"tdd/react-tdd-style/#1-component-tests-most-common","title":"\ud83d\udd0d 1. Component Tests (Most Common)","text":"<p>You test what the user sees and can interact with \u2014 without mocking internals.</p> Example<pre><code>test(\"shows error if email is invalid\", () =&gt; {\n  render(&lt;LoginForm /&gt;);\n  fireEvent.change(screen.getByLabelText(/email/i), {\n    target: { value: \"invalid-email\" },\n  });\n  fireEvent.click(screen.getByText(/submit/i));\n\n  expect(screen.getByText(/invalid email/i)).toBeInTheDocument();\n});\n</code></pre> <ul> <li>No mocks</li> <li>Tests actual rendered output</li> <li>Focus on visible behavior, not implementation</li> </ul>"},{"location":"tdd/react-tdd-style/#2-custom-hook-tests","title":"\ud83d\udd01 2. Custom Hook Tests","text":"<p>Hooks return values or functions \u2014 great for direct logic testing (Chicago style).</p> <pre><code>import { renderHook, act } from \"@testing-library/react-hooks\";\nimport useCounter from \"./useCounter\";\n\ntest(\"increments counter\", () =&gt; {\n  const { result } = renderHook(() =&gt; useCounter());\n  act(() =&gt; result.current.increment());\n  expect(result.current.count).toBe(1);\n});\n</code></pre> <ul> <li>Tests state transitions</li> <li>No need to mock anything</li> <li>Treats the hook like a pure function</li> </ul>"},{"location":"tdd/react-tdd-style/#3-utility-logic-functions","title":"\ud83d\udcd0 3. Utility / Logic Functions","text":"<p>Chicago-style is perfect for testing small helper logic:</p> <pre><code>import { formatName } from \"./utils\";\n\ntest(\"formats name correctly\", () =&gt; {\n  expect(formatName(\"john\", \"doe\")).toBe(\"John Doe\");\n});\n</code></pre>"},{"location":"tdd/react-tdd-style/#what-it-avoids","title":"\ud83e\udde0 What It Avoids","text":"<ul> <li>\u274c Mocking internal props/state</li> <li>\u274c Testing private methods or component internals</li> <li>\u274c Over-isolation of components</li> </ul> <p>Instead, it encourages simple tests that reflect what the user would see or do.</p>"},{"location":"tdd/react-tdd-style/#when-it-mixes-with-other-styles","title":"\ud83d\udd04 When It Mixes with Other Styles","text":"Style When You Might Use It in React London Style Mocking APIs or services (e.g., <code>AuthService</code>) BDD/ATDD Cypress or Playwright for user flows Integration TDD Testing multi-component flows"},{"location":"tdd/react-tdd-style/#summary_1","title":"\ud83d\udccc Summary","text":"<p>In React, Chicago-style TDD is best used to test:</p> <ul> <li>\u2705 Component rendering and behavior</li> <li>\u2705 Hook logic</li> <li>\u2705 State updates and transitions</li> <li>\u2705 Output based on input \u2014 not internal implementation</li> </ul> <p>It keeps your tests focused, maintainable, and aligned with user expectations.</p>"},{"location":"tdd/tdd-styles/","title":"TDD Styles","text":""},{"location":"tdd/tdd-styles/#tdd-styles","title":"TDD Styles","text":"<p>Test-Driven Development (TDD) is not a one-size-fits-all practice. There are multiple styles of TDD, each with different goals, tools, and techniques. Choosing the right style helps ensure your tests support design, provide rapid feedback, and guide refactoring safely.</p>"},{"location":"tdd/tdd-styles/#tdd-style-comparison","title":"\ud83d\udcda TDD Style Comparison","text":"Type / Style Focus Mock Usage Best For Classic TDD (London) Interaction &amp; behavior High UI, services, complex system interactions Chicago TDD (Detroit) Logic &amp; state correctness Low Algorithms, pure functions, hooks ATDD / BDD User/business behavior Medium User flows, acceptance tests Component-Level TDD UI components Low-Medium React/Vue components Integration TDD Multiple units working together Medium End-to-end logic, feature integration"},{"location":"tdd/tdd-styles/#classic-tdd-london-style","title":"\ud83d\udd39 Classic TDD (London Style)","text":"<ul> <li>Focuses on object interactions.</li> <li>Encourages using test doubles (mocks, stubs).</li> <li>Tests drive the collaboration structure between objects.</li> </ul> Example (JavaScript)<pre><code>test(\"calls AuthService with correct credentials\", () =&gt; {\n  const authService = { login: jest.fn() };\n  const controller = new LoginController(authService);\n  controller.login(\"user\", \"pass\");\n  expect(authService.login).toHaveBeenCalledWith(\"user\", \"pass\");\n});\n</code></pre>"},{"location":"tdd/tdd-styles/#chicago-tdd-detroit-style","title":"\ud83d\udd39 Chicago TDD (Detroit Style)","text":"<ul> <li>Focuses on correctness of logic and state.</li> <li>Avoids mocks unless absolutely necessary.</li> <li>Tests verify inputs and outputs through public APIs.</li> </ul> title<pre><code>test(\"returns true for valid email\", () =&gt; {\n  expect(isValidEmail(\"user@example.com\")).toBe(true);\n});\n</code></pre>"},{"location":"tdd/tdd-styles/#atdd-bdd-acceptance-behavior-driven-development","title":"\ud83d\udd39 ATDD / BDD (Acceptance &amp; Behavior-Driven Development)","text":"<ul> <li>Tests are written in natural language or high-level descriptions.</li> <li>Often created by or with business stakeholders.</li> <li>Tools: Cucumber, Cypress, Playwright</li> </ul> Example (Gherkin)<pre><code>Feature: Login\n  Scenario: Successful login\n    Given the user is on the login page\n    When they enter valid credentials\n    Then they should see the dashboard\n</code></pre>"},{"location":"tdd/tdd-styles/#component-level-tdd-ui","title":"\ud83d\udd39 Component-Level TDD (UI)","text":"<ul> <li>Focuses on individual UI component behavior.</li> <li>Tests DOM changes, state updates, and prop behavior.</li> <li>Common in React/Vue projects with tools like React Testing Library.</li> </ul> Example (React)<pre><code>test(\"disables submit button when input is empty\", () =&gt; {\n  render(&lt;LoginForm /&gt;);\n  expect(screen.getByRole(\"button\")).toBeDisabled();\n});\n</code></pre>"},{"location":"tdd/tdd-styles/#integration-tdd","title":"\ud83d\udd39 Integration TDD","text":"<ul> <li>Ensures multiple modules work together.</li> <li>Often used when testing workflows, APIs, or services.</li> <li>Helps verify real-world use cases or feature flows.</li> </ul> Example<pre><code>test(\"user logs in and loads profile\", async () =&gt; {\n  const response = await loginAndFetchProfile(\"user\", \"pass\");\n  expect(response.profile.username).toBe(\"user\");\n});\n</code></pre>"},{"location":"tdd/tdd-styles/#choosing-the-right-style","title":"\ud83e\udde0 Choosing the Right Style","text":"Scenario Recommended Style Pure logic or utility functions Chicago Style Service-oriented architecture London Style Frontend components Component TDD Business-driven requirements BDD / ATDD Feature or flow-level testing Integration TDD <p>Each style has its strengths. It's common to use multiple styles in a single project based on what you're testing.</p>"},{"location":"tdd/tdd-styles/#summary","title":"\ud83c\udfc1 Summary","text":"<ul> <li>Use Chicago-style TDD for logic-heavy code and React hooks.</li> <li>Use London-style TDD when designing interactions between services or classes.</li> <li>Use BDD/ATDD for user acceptance criteria and stakeholder involvement.</li> <li>Use integration tests to confirm multiple parts work together in real scenarios.</li> </ul> <p>TDD is not just about testing \u2014 it's about driving better design through feedback and focus.</p>"},{"location":"tdd/test-last-approach/","title":"Test-Last Approach","text":""},{"location":"tdd/test-last-approach/#test-last-approach","title":"Test-Last Approach","text":"<p>Yes, the test-last approach in TDD (Test-Driven Development) is typically used when working with an already built application, rather than when building an app from scratch.</p>"},{"location":"tdd/test-last-approach/#overview","title":"Overview","text":"<p>Here\u2019s a quick breakdown:</p>"},{"location":"tdd/test-last-approach/#test-first-vs-test-last-in-tdd","title":"\ud83e\uddea Test-First vs Test-Last in TDD","text":"Approach When Used Description Test-First When building from scratch You write tests before writing any production code. This is the core of traditional TDD. Test-Last When working with existing code You write tests after writing or refactoring the code. It's often used to improve test coverage or refactor safely."},{"location":"tdd/test-last-approach/#when-to-use-test-last","title":"\u2705 When to Use Test-Last","text":"<ul> <li>You are refactoring legacy code.</li> <li>You need to add tests to existing functionality that wasn't covered before.</li> <li>The original codebase wasn\u2019t built with TDD.</li> <li>You\u2019re gradually introducing better test practices into an old or evolving codebase.</li> </ul>"},{"location":"tdd/test-last-approach/#test-last-is-not-traditional-tdd","title":"\ud83d\udeab Test-Last Is Not Traditional TDD","text":"<p>Even though people call it \"test-last\" in some TDD circles, it's technically not TDD in the strict sense, because TDD requires writing the test first to drive development. But it's a practical approach in real-world projects, especially with legacy systems.</p>"},{"location":"tdd/test-last-approach/#refactoring","title":"Refactoring","text":"<p>Yes, you can\u2014and often should\u2014use a test-last approach when you're dealing with an already built application that needs refactoring. But there\u2019s an important nuance: you're not just writing tests last, you're writing characterization tests first\u2014before refactoring.</p>"},{"location":"tdd/test-last-approach/#why-test-last-with-characterization-works-for-refactoring","title":"\ud83e\uddea Why Test-Last (with Characterization) Works for Refactoring","text":"<p>When the app already exists:</p> <ol> <li>You don\u2019t want to change behavior yet.</li> <li>So you write tests that capture what the system currently does\u2014even if the behavior is wrong or messy.</li> <li>Once you have those tests in place, you can refactor with confidence.</li> </ol> <p>This technique is central to legacy code refactoring.</p>"},{"location":"tdd/test-last-approach/#what-to-do-practical-steps","title":"\u2705 What to Do: Practical Steps","text":""},{"location":"tdd/test-last-approach/#1-write-characterization-tests","title":"1. Write Characterization Tests","text":"<p>Tests that describe what the system does now, not what it should ideally do.</p> <pre><code>// BEFORE: messy or unclear code\nconst result = legacyFunction(\"abc\");\nexpect(result).toEqual(\"abc_xyz\"); // even if that behavior is weird, capture it\n</code></pre>"},{"location":"tdd/test-last-approach/#2-refactor-the-code","title":"2. Refactor the Code","text":"<p>Now, with those tests guarding you, start cleaning up:</p> <ul> <li>Extract methods</li> <li>Rename variables</li> <li>Break dependencies</li> <li>Improve structure</li> </ul> <p>If a test fails, you\u2019ll know you've changed behavior\u2014and can stop to decide if that\u2019s okay.</p>"},{"location":"tdd/test-last-approach/#uncle-bobs-advice-on-this","title":"\ud83d\udcd8 Uncle Bob's Advice on This","text":"<p>Uncle Bob strongly supports writing tests before refactoring, even in test-last scenarios:</p> <p>\"You cannot refactor without tests. If you try, you are just changing code blindly and hoping it still works.\" \u2014 Robert C. Martin</p> <p>His book \u201cWorking Effectively with Legacy Code\u201d (by Michael Feathers, which he endorses) emphasizes this strategy heavily.</p>"},{"location":"tdd/test-last-approach/#quick-guidelines","title":"\ud83e\udde0 Quick Guidelines","text":"Refactoring Scenario Suggested Testing Approach Code already exists \u2705 Characterization tests (Test-Last) New functionality \u2705 Use Test-First (TDD) Unknown behavior / bugs \ud83d\udd75\ufe0f Add tests to lock current behavior High-risk change \ud83d\udee1 Add integration/system-level tests"},{"location":"tdd/test-last-approach/#final-verdict","title":"\u2705 Final Verdict","text":"<p>Yes, you can use a test-last approach when refactoring existing code \u2014 but do so deliberately and strategically:</p> <ul> <li>Focus on characterizing current behavior first.</li> <li>Then refactor safely with confidence.</li> <li>Once code is clean, consider shifting to TDD for new changes.</li> </ul>"},{"location":"tdd/test-last-approach/#characterization-test","title":"Characterization Test","text":""},{"location":"tdd/test-last-approach/#what-is-a-characterization-test","title":"\ud83e\uddea What is a Characterization Test?","text":"<p>A characterization test is written after the code exists but before you refactor. Its goal is to capture the current behavior \u2014 even if that behavior is wrong or ugly \u2014 so you can safely refactor without changing it accidentally.</p>"},{"location":"tdd/test-last-approach/#step-by-step-characterization-testing-for-refactoring","title":"\ud83d\udd27 Step-by-Step: Characterization Testing for Refactoring","text":""},{"location":"tdd/test-last-approach/#scenario","title":"\ud83c\udfaf Scenario:","text":"<p>You have a legacy function that formats user data:</p> <pre><code>// legacy.js\nfunction formatUser(user) {\n  return user.name + \"-\" + user.age + \"yrs\";\n}\n</code></pre> <p>Your goal: refactor it to be more readable.</p>"},{"location":"tdd/test-last-approach/#step-1-add-a-characterization-test","title":"\u2705 Step 1: Add a Characterization Test","text":"<p>Use your testing framework (e.g. Jest):</p> <pre><code>// legacy.test.js\nconst { formatUser } = require(\"./legacy\");\n\ntest(\"formatUser returns name-ageyrs format\", () =&gt; {\n  const input = { name: \"Alice\", age: 30 };\n  const result = formatUser(input);\n\n  expect(result).toBe(\"Alice-30yrs\");\n});\n</code></pre> <p>This test \u201clocks in\u201d the current behavior.</p>"},{"location":"tdd/test-last-approach/#step-2-refactor-the-code","title":"\u2705 Step 2: Refactor the Code","text":"<p>Once that test passes, you can safely refactor:</p> <pre><code>// REFACTORED: legacy.js\nfunction formatUser({ name, age }) {\n  return `${name}-${age}yrs`;\n}\n</code></pre> <p>The test still passes \u2705 \u2014 you\u2019ve changed the implementation without altering behavior.</p>"},{"location":"tdd/test-last-approach/#step-3-rinse-and-repeat","title":"\u2705 Step 3: Rinse and Repeat","text":"<ul> <li>Keep writing tests around legacy functions.</li> <li>Extract small pieces.</li> <li>Once you feel safe, improve names, split responsibilities, remove duplication.</li> </ul>"},{"location":"tdd/test-last-approach/#example-messy-function-refactoring","title":"\ud83d\udd01 Example: Messy Function Refactoring","text":""},{"location":"tdd/test-last-approach/#before-ugly-logic","title":"\ud83e\uddf1 Before (ugly logic)","text":"<pre><code>function discount(price, customer) {\n  if (customer.status === \"VIP\") return price * 0.7;\n  else if (customer.status === \"Regular\") return price * 0.9;\n  else return price;\n}\n</code></pre>"},{"location":"tdd/test-last-approach/#write-characterization-test","title":"\ud83e\uddea Write Characterization Test","text":"<pre><code>test(\"VIP customers get 30% off\", () =&gt; {\n  expect(discount(100, { status: \"VIP\" })).toBe(70);\n});\n</code></pre>"},{"location":"tdd/test-last-approach/#refactor-confidently","title":"\ud83e\uddfc Refactor Confidently","text":"<pre><code>function discount(price, customer) {\n  const discounts = { VIP: 0.7, Regular: 0.9 };\n  return price * (discounts[customer.status] ?? 1);\n}\n</code></pre> <p>Test still passes? \u2705 You\u2019re safe.</p>"},{"location":"tdd/test-last-approach/#benefits","title":"\ud83d\udd12 Benefits","text":"<ul> <li>Protects against breaking existing behavior</li> <li>Enables safe, incremental refactoring</li> <li>Helps you understand confusing or undocumented legacy cod</li> </ul>"},{"location":"tdd/types/","title":"Types","text":""},{"location":"tdd/types/#types-of-tdd","title":"Types of TDD","text":"<p>Although TDD is a broad and diverse concept with many variations and different schools, such as UTDD, BDD, ATDD, and others, it traditionally implied Unit Test\u2013Driven Development or UTDD.</p> <p>However, the TDD discussed in this book is an extended version of the conventional concept, known as Acceptance Test\u2013Driven Development (ATDD), which places a strong emphasis on writing acceptance tests from the business perspective and using them to drive the development of production code.</p> React developers typically use <ul> <li>Chicago-style TDD at the component level (preferred for clarity and resilience)</li> <li>London-style selectively when testing interactions with side effects or external services</li> <li>BDD/ATDD tools like Cypress for high-level user flow testing</li> </ul>"},{"location":"tdd/types/#types","title":"Types","text":"<p>TDD (Test-Driven Development) doesn't have \"types\" in a strict formal sense, but in practice, TDD can be applied at different levels of abstraction, and these are often referred to as different types or styles of TDD.</p> <p>Here are the most commonly recognized types of TDD:</p>"},{"location":"tdd/types/#1-classic-tdd-outside-in-top-down-london-style","title":"1. Classic TDD (Outside-In / Top-Down / London Style)","text":"<ul> <li>Focuses on behavior first, using mocks/stubs to define the interaction between objects.</li> <li>Common in front-end (like React) and service-oriented architecture.</li> <li>Tests are written based on how modules interact, not their internal implementation.</li> </ul> Quote <p>Example:</p> <ul> <li>You write a test that your UI calls a <code>login()</code> function, but not how the function works internally.</li> </ul> <p>Emphasizes:</p> <ul> <li>Mocking dependencies</li> <li>Fast feedback</li> <li>Loose coupling</li> </ul>"},{"location":"tdd/types/#2-chicago-style-tdd-inside-out-detroit-style-state-based","title":"2. Chicago Style TDD (Inside-Out / Detroit Style / State-Based)","text":"<ul> <li>Focuses on the internal correctness of a unit (like a class, function, or hook).</li> <li>You test the actual return values and state, not interactions.</li> </ul> Quote <p>Example:</p> <ul> <li>Testing a function that calculates total price based on input values.</li> </ul> <p>Emphasizes:</p> <ul> <li>Pure logic</li> <li>Fewer mocks</li> <li>Simpler tests for business logic</li> </ul>"},{"location":"tdd/types/#3-acceptance-test-driven-development-atdd-specification-by-example","title":"3. Acceptance Test-Driven Development (ATDD) / Specification by Example","text":"<ul> <li>Focuses on writing high-level acceptance tests first, from the user or stakeholder's perspective.</li> <li>Commonly used with tools like Cucumber, Playwright, Cypress, etc.</li> </ul> Quote <p>Example:</p> <ul> <li>Test that a user can log in successfully and is redirected to a dashboard.</li> </ul> <p>Emphasizes:</p> <ul> <li>Real user scenarios</li> <li>Business rules</li> <li>Often BDD-style (Behavior-Driven Development)</li> </ul>"},{"location":"tdd/types/#4-component-level-tdd","title":"4. Component-Level TDD","text":"<ul> <li>Specific to component-based frameworks like React.</li> <li>Write tests around UI components using tools like React Testing Library.</li> </ul> Quote <p>Example:</p> <ul> <li>Test that a <code>Modal</code> opens and closes correctly on button click.</li> </ul> <p>Emphasizes:</p> <ul> <li>UI behavior</li> <li>DOM interaction</li> <li>Accessibility</li> </ul>"},{"location":"tdd/types/#5-integration-tdd","title":"5. Integration TDD","text":"<ul> <li>Write tests that ensure multiple parts of the system work together correctly.</li> <li>Can be done with mocked APIs, or full-stack test environments (e.g., MSW + React Testing Library + RTK Query).</li> </ul> <p>Useful for:</p> <ul> <li>Testing custom hooks with async logic</li> <li>Ensuring Redux + API + UI all sync properly</li> </ul>"},{"location":"tdd/types/#summary-table","title":"Summary Table","text":"Type / Style Focus Mock Usage Best For Classic TDD (London) Interaction &amp; behavior High UI, services, complex system interactions Chicago TDD (Detroit) Logic &amp; state correctness Low Algorithms, pure functions, hooks ATDD / BDD User/business behavior Medium User flows, acceptance tests Component-Level TDD UI components Low-Medium React/Vue components Integration TDD Multiple units working together Medium End-to-end logic, feature integration"},{"location":"tdd/types/#real-world","title":"Real World","text":"<p>Great question \u2014 in real-world production software, the most commonly used types of TDD depend on:</p> <ul> <li>the size of the team,</li> <li>codebase complexity,</li> <li>risk tolerance (e.g., fintech vs internal dashboard),</li> <li>and the tech stack (e.g., React, Node.js, microservices).</li> </ul> <p>Here\u2019s a breakdown of what is actually used in production (based on industry practices):</p>"},{"location":"tdd/types/#most-common-in-real-world-react-web-apps","title":"\ud83e\udd47 Most Common in Real-World React &amp; Web Apps","text":"TDD Type Usage in Real World Why It's Used \u2705 Chicago Style (Inside-Out) \u2b50\u2b50\u2b50\u2b50\u2606 (High) Ideal for logic-heavy code (e.g., pure functions, hooks, reducers). Fast, stable, and easy to maintain. \u2705 Component-Level TDD \u2b50\u2b50\u2b50\u2b50\u2606 (High) Crucial for testing UI behavior in React. Used with React Testing Library. \u2705 Integration TDD \u2b50\u2b50\u2b50\u2b50\u2606 (High) Important for testing how things connect: hooks + APIs, Redux + UI, etc. \u2705 Classic (Outside-In) \u2b50\u2b50\u2606\u2606\u2606 (Medium) Used more in backend (Node.js), or where mocking and interaction testing are critical. Less used in UI. \u2705 Acceptance/ATDD/BDD \u2b50\u2b50\u2606\u2606\u2606 (Medium) Used in high-stakes flows (login, checkout). Often in e-commerce, fintech. Requires more tooling and discipline."},{"location":"tdd/types/#most-teams-use-a-hybrid-of-these","title":"\ud83d\udd25 Most Teams Use a Hybrid of These:","text":"<p>\ud83e\udde9 Example from a real app:</p> Layer Test Type Used Utility functions Chicago TDD (pure unit tests) Custom hooks Inside-Out TDD + Integration React components Component-level + behavior tests API endpoints Integration TDD (w/ MSW or mock server) Login/Checkout ATDD/BDD-style with Cypress or Playwright Async RTK Query Integration (mock server, async logic)"},{"location":"tdd/types/#rarely-used-alone","title":"\u274c Rarely Used Alone","text":"<p>Classic TDD (Outside-In) is less common in React because:</p> <ul> <li>Mock-heavy tests are brittle.</li> <li>Modern libraries favor testing real behavior, not mocks.</li> <li>Harder to refactor with confidence when mocks dictate structure.</li> </ul> <p>ATDD / BDD are less common in smaller teams or startups due to:</p> <ul> <li>Extra tooling (like Gherkin, Cucumber, etc.)</li> <li>Steeper learning curve and overhead</li> </ul>"},{"location":"tdd/types/#in-summary","title":"\ud83e\udde0 In Summary:","text":"Rank Most Used TDD Type in Real React Projects \ud83e\udd47 1 Chicago Style (pure logic testing) \ud83e\udd48 2 Component-Level TDD (React components) \ud83e\udd49 3 Integration TDD (hooks + API + UI) \ud83c\udfc5 4 Acceptance TDD / BDD (in critical flows) \ud83c\udfc1 5 Classic TDD (mock-heavy, backend-oriented) <p>If you're building a React or full-stack app, I recommend focusing on:</p> <ul> <li>\u2705 Pure unit tests (Chicago)</li> <li>\u2705 Component + behavior tests (with React Testing Library)</li> <li>\u2705 Integration tests with mocked APIs (e.g. MSW)</li> <li>\ud83d\udd01 Optional: Add E2E (Cypress, Playwright) if your app has login, checkout, onboarding flows</li> </ul>"},{"location":"tdd/types/#reference","title":"Reference","text":"<ul> <li>Test-Driven Development with React and TypeScript, Second Edition by Juntao Qiu</li> </ul>"},{"location":"testing/developer-vs-qa/","title":"Dev vs QA Role","text":""},{"location":"testing/developer-vs-qa/#developer-vs-qa-role-in-testing","title":"Developer vs QA role in testing","text":"<p>In React development, the responsibility for writing unit tests, integration tests, and end-to-end (E2E) tests can vary depending on the team's structure and workflow. However, here is a general breakdown:</p>"},{"location":"testing/developer-vs-qa/#developers-role","title":"Developer's Role","text":"<p>React developers are typically responsible for writing unit tests and integration tests:</p> <ul> <li> <p>Unit Tests: These test individual components in isolation to ensure they function as expected (e.g., testing button clicks or state changes). Developers often use tools like Jest and React Testing Library for these tests.</p> </li> <li> <p>Integration Tests: These verify how multiple components interact with each other, ensuring proper functionality when components work together. Developers usually handle these tests as part of their coding workflow.</p> </li> </ul>"},{"location":"testing/developer-vs-qa/#qa-engineers-role","title":"QA Engineer's Role","text":"<p>Quality Assurance (QA) engineers focus more on end-to-end (E2E) testing and overall application quality:</p> <ul> <li> <p>E2E Tests: These simulate real user behavior across the entire application to ensure it works as intended in real-world scenarios. QA engineers typically design and execute these tests using tools like Cypress or Selenium.</p> </li> <li> <p>QA engineers also document testing phases, report bugs, and collaborate with developers to troubleshoot issues.</p> </li> </ul>"},{"location":"testing/developer-vs-qa/#shared-responsibility","title":"Shared Responsibility","text":"<p>In modern DevOps environments, testing responsibilities are often shared:</p> <ul> <li> <p>Developers are involved in early-stage testing to catch bugs during development.</p> </li> <li> <p>QA engineers ensure the application meets defined quality standards before release.</p> </li> </ul> <p>As a React developer, you should focus on unit and integration tests but may occasionally contribute to E2E testing, especially in smaller teams without dedicated QA personnel.</p> <ul> <li>Test behaviour, not the implementation</li> <li>Refactoring shouldn't break tests</li> </ul> <p>by - What I've Learned About Testing React Apps - Unit Tests </p>"},{"location":"testing/developer-vs-qa/#reference","title":"Reference","text":"<ul> <li>How To Write Integration Tests With Jest And React Testing Library</li> <li>React Testing: How to test React components?</li> <li>Guide to Hiring a React Developer with Testing and QA Skills</li> <li> <p>What I've Learned About Testing React Apps - Unit Tests</p> </li> <li> <p>Understanding the Roles in Quality Assurance</p> </li> <li>QA Tester job description</li> <li> <p>What Is a QA Tester?</p> </li> <li> <p>What is E2E? A guide to end-to-end testing</p> </li> </ul>"},{"location":"testing/intro/","title":"Overview","text":""},{"location":"testing/intro/#testing","title":"Testing","text":"<p>Testing is a crucial part of web application development, ensuring your app works as expected, is reliable, and provides a good user experience. Since you\u2019ve built applications with JavaScript, React, and Next.js but haven\u2019t done testing yet, I\u2019ll walk you through the types of testing commonly used in web applications, explain where to start, and address whether you should test first or later.</p> <p></p> <p></p>"},{"location":"testing/intro/#starting","title":"Starting","text":"<p>Deciding where to start with testing or which type is \"most important\" depends on your goals, your app\u2019s current state, and your experience level. Since you\u2019ve built an app with JavaScript, React, and Next.js but haven\u2019t done any testing yet, I\u2019ll break this down to help you choose.</p> Where Should You Start? <p>For someone new to testing with an existing app, Unit Testing is the best starting point. Here\u2019s why:</p> <ul> <li>Ease of Learning: Unit tests focus on small, isolated pieces (e.g., a single React component or function), making them simpler to understand and write compared to broader tests like E2E.</li> <li>Quick Feedback: They run fast and give immediate results, helping you build confidence in testing.</li> <li>Foundation: Mastering unit testing sets you up to tackle more complex types later (e.g., integration or E2E).</li> <li>Practical for Your Stack: React and Next.js are component-based, so unit testing aligns naturally with your codebase.</li> </ul> <p>Starting Example: Use Jest and React Testing Library to test a simple component (like the <code>Button</code> example from earlier). It\u2019s low effort to set up and gives you a tangible win.</p> Which Testing Type is Most Important? <p>\"Most important\" varies by context, but here\u2019s how to think about it:</p> <ol> <li> <p>Unit Testing</p> <ul> <li>Importance: High for catching bugs early in individual pieces of code. It\u2019s the backbone of a solid test suite.</li> <li>Why: Prevents small errors from snowballing. For example, ensuring a button\u2019s click handler works saves headaches later.</li> <li>When it\u2019s critical: For apps with lots of reusable logic or components (common in React/Next.js).</li> </ul> </li> <li> <p>Integration Testing</p> <ul> <li>Importance: High if your app relies on components working together (e.g., forms, API calls, state management).</li> <li>Why: Catches issues unit tests miss, like a form not passing data correctly to a parent component.</li> <li>When it\u2019s critical: If your app has complex interactions between parts.</li> </ul> </li> <li> <p>End-to-End (E2E) Testing</p> <ul> <li>Importance: Very high for ensuring the app works as a whole from a user\u2019s perspective.</li> <li>Why: Validates real-world flows (e.g., login \u2192 dashboard \u2192 logout). It\u2019s the closest to how users experience your app.</li> <li>When it\u2019s critical: For production apps where user experience and reliability are non-negotiable (e.g., e-commerce, SaaS).</li> </ul> </li> <li> <p>Other Types</p> <ul> <li>Snapshot: Useful for UI consistency but less critical early on.</li> <li>Visual Regression: Important for design-heavy apps, less so for functionality.</li> <li>Performance: Vital for user retention but can wait until core functionality is tested.</li> <li>Accessibility: Essential for inclusivity and compliance, but you can layer it in after basics.</li> <li>Manual: Good for exploration, but automation is more scalable.</li> </ul> </li> </ol> Recommendation <ul> <li>Start with Unit Testing: It\u2019s the most approachable and gives you a strong base. Set up Jest and React Testing Library, then test a few key components (e.g., a button, a form input). This builds your testing skills without overwhelming you.</li> <li>Most Important Long-Term: E2E Testing often becomes the most critical as your app grows because it ensures the entire system works for users. However, it\u2019s harder to start with due to setup complexity (e.g., Cypress) and requires a stable app to test effectively.</li> </ul>"},{"location":"testing/intro/#practical-plan","title":"Practical Plan","text":"<ol> <li> <p>Day 1: Install Jest (<code>npm install --save-dev jest</code>) and React Testing Library (<code>npm install --save-dev @testing-library/react</code>), then write a unit test for a component you\u2019ve already built. Example:</p> <pre><code>test(\"button renders\", () =&gt; {\n  render(&lt;Button label=\"Click me\" /&gt;);\n  expect(screen.getByText(\"Click me\")).toBeInTheDocument();\n});\n</code></pre> </li> <li> <p>Next Step: After a few unit tests, try an integration test for a component group (e.g., a form with a submit button).</p> </li> <li> <p>Later: Add E2E testing with Cypress once you\u2019re comfortable, focusing on key user flows.</p> </li> </ol> Why Not Start Elsewhere? <ul> <li>E2E: Too complex for a beginner; better after you\u2019ve tested smaller pieces.</li> <li>Performance/Accessibility: Important but secondary until functionality is solid.</li> <li>Manual: Useful now, but automation (starting with unit tests) scales better.</li> </ul> <p>Conclusion: Start with unit testing for its simplicity and immediate value. Long-term, E2E testing might be the most important for your app\u2019s success, but build up to it. Let me know if you need help setting up that first unit test!</p>"},{"location":"testing/react/","title":"React","text":""},{"location":"testing/react/#introducing-jest","title":"Introducing Jest","text":"<p>Jest is a test framework developed by Meta (n\u00e9e Facebook). Thanks to its rich feature set and solid performance, it\u2019s become the most popular library for testing JavaScript code in recent years.</p> Jest vs. Vitest <p>This chapter introduces you to testing with Jest, due to its popularity and ease of setup. However, later chapters will use Vitest, a Jest alternative that offers even faster performance when used in tandem with the Vite build tool. Vitest is designed for compatibility with tests written for Jest, so rest assured that the knowledge you pick up in this chapter will carry over!</p> <p>Unlike its forerunners, which expect to run in a browser environment, Jest runs in a Node process.</p>"},{"location":"testing/react/#adding-jest-as-a-dependency","title":"Adding Jest as a Dependency","text":"<p>Use npm to install the jest package:</p> <pre><code>$ npm install --save-dev jest@29.4.3\n</code></pre> <pre><code>// package.json\n{\n    ...\n    \"devDependencies\": {\n        \"jest\": \"^29.4.3\"\n    }\n}\n</code></pre> What Does the Caret (^) Before Version Numbers Mean? <p>By default, npm lists dependencies in <code>package.json</code> with a caret (<code>^</code>). The caret creates a version range that allows for minor updates and patches. So, <code>jest@^29.4.3</code> includes any version of <code>jest</code> from version <code>29.4.3</code> up to, but not including, <code>30.0.0</code>. According to <code>semver</code> principles, newer versions in that range should be backward compatible because package authors should bump the major version when making any breaking change. But be warned\u2014package authors often ignore semver principles!</p> <p>Fortunately, the other file <code>npm</code> created, <code>package-lock.json</code>, stores the exact version that was installed. As long as that lockfile is preserved, anyone who installs the project will get the exact same version of <code>jest</code> that you did. Put another way, <code>npm install</code> gives <code>package-lock.json</code> precedence over <code>package.json</code>. To install the latest version allowed by <code>package.json</code>, use the <code>npm update</code> command.</p> <p>Now Jest is installed and ready for you to use. However, it\u2019s in the project\u2019s <code>node_modules</code>, not on your PATH. To run it, you\u2019ll need to call on another tool\u2014npx.</p>"},{"location":"testing/react/#running-project-scripts-with-npm","title":"Running Project Scripts with npm","text":"<pre><code>$ npx jest --version\n29.4.3\n</code></pre> <p>The test script is special to npm; you can execute it with either <code>npm run test</code> or just <code>npm test</code>. You should see the same output that you got with npx jest:</p> <pre><code>$ npm test\n</code></pre> <p>No tests found, exiting with code 1</p>"},{"location":"testing/react/#writing-a-test","title":"Writing a Test","text":"<p>Time for your first test! Create a file called greeting.test.js:</p> <pre><code>// greeting.test.js\nconst greeting = (guest) =&gt; `Hello, ${guest}!`;\n\ndescribe(\"greeting()\", () =&gt; {\n  it(\"says hello\", () =&gt; {\n    expect(greeting(\"Jest\")).toBe(\"Hello, Jest!\");\n  });\n});\n</code></pre> <ol> <li> <p><code>describe()</code> declares a test suite, which is a grouping of tests. Its first argument is a name, and the second is a function containing one or more tests.</p> </li> <li> <p><code>it()</code> declares a test. Its first argument is a name, and the second is a function with the actual test code.</p> </li> <li> <p><code>expect()</code> creates an assertion. It takes a single argument, typically a value generated by the code being tested, and returns an object that provides a set of matcher functions.</p> </li> <li> <p><code>toBe()</code> is a matcher that performs a strict equality test between the value being tested (the <code>expect()</code> argument) and the expected value (its own argument).</p> </li> </ol> <p>Note the grammatical convention here: the test suite name (\"<code>greeting()</code>\") is a noun, and the test name (\"<code>says hello</code>\") is a verb. Together, they form a complete sentence describing the functionality covered by the test (\"<code>greeting()</code> says hello\").</p> <p>This convention helps make test output easy to read. You can learn more about all of these methods in the Jest API docs.</p> <pre><code>$ npm test\n\n\nPASS ./greeting.test.js\n    greeting()\n        \u2713 says hello (1 ms)\n\nTest Suites: 1 passed, 1 total\nTests:\n1 passed, 1 total\nSnapshots:\n0 total\nTime:\n0.159 s\nRan all test suites\n</code></pre> <p>Excellent! Jest found the test file, ran the test, and confirmed that <code>greeting('Jest')</code> produces the string '<code>Hello, Jest!</code>'.</p> <p>You can go ahead and delete <code>greeting.test.js</code>:</p>"},{"location":"testing/react/#the-tao-of-test-driven-development","title":"The Tao of Test-Driven Development","text":"<p>Test-driven development (TDD) is sometimes defined as writing tests first.</p> <p>Although that\u2019s an important part of the methodology, it\u2019s not the essence. The essence of TDD is rapid iteration. You\u2019ll find that you learn more quickly from iterating\u2014writing small, easy-to-understand pieces of code one at a time\u2014than you would from trying to plan out a complex program from the ground up.</p>"},{"location":"testing/react/#reference","title":"Reference","text":"<ul> <li>Test-Driven React, 2nd Edition by Trevor Burnham</li> </ul>"},{"location":"testing/relay/","title":"Relay","text":""},{"location":"testing/relay/#relay","title":"Relay","text":""},{"location":"testing/relay/#others","title":"Others","text":"most commonly used patterns that React offers <ul> <li>Controlled components</li> <li>Functional components</li> <li>Conditional rendering</li> <li>Rendering children</li> </ul> <p>Controlled components</p> <p>By definition, a component is uncontrolled whenever the value is not set by a property through React, but only saved and taken from the real browser Document Object Model (DOM). The value of an input is then retrieved from a reference to the DOM Node and is not managed and taken from React's component state.</p> <p>When using uncontrolled components and working directly with DOM elements, the problem is that you leave the normal React workflow. You are no longer able to handle conditions and, therefore, trigger other events inside of React.</p> Tip <p>If you need a deeper understanding of which approach is a better solution for your specific case, take a look at controlled-vs-uncontrolled-inputs-react.</p> <p>Functional components</p> <p>One fundamental and efficient solution for writing well-structured and reusable React components is the use of functional components.</p> <ul> <li>Full-Stack Web Development with GraphQL and React Second Edition by Sebastian Grebe, pg: 160</li> </ul>"},{"location":"testing/relay/#why-relay","title":"Why Relay?","text":"<p>React enabled us to create declarative UI views, and model the state for those views and not the transactions to render them. With React, we simply define views as functions of data.</p> <p>Working with data, however, was the missing piece in the puzzle. Relay is one option to complete that puzzle and act as the data manager for React applications.</p> <p>Just like React made declarative programming easier for building user interfaces, Relay can make declarative programming easier for fetching and mutating the data required for these user interfaces.</p> <p>With Relay, we just declare what we need to happen to the data, and Relay will do the actual steps needed to satisfy our needs.</p> <p>Working with data is always a challenge. We need to be aware of the performance issues around data communication. Are we making optimal requests, or are we making multiple requests that can be batched and further optimized? What should we do when a request fails? How do we handle errors? Should we retry a failed request? If we retry, when should we give up?</p> <p>Furthermore, when users interact with a user interface and make some changes, we want them to see their changes reflected right away while we attempt to persist these changes to the database. We want to be able to either confirm the changes or roll them back once we have a response from the server.</p> <p>There is also the task of paginating data in a smart way that can handle changed items. Think about the case where we fetched 10 items from a list, and before we fetch the next 10 items, an item was added or removed from the 10 items we originally fetched. Both the client and the server need to be aware of these edge cases.</p> <p>There is also caching on both clients and servers. What can safely go to the cache and what cannot? How do we handle merging of cached data with new data? When do we expire things out of the cache? How do we cache related objects without duplicating them? Think about caching a comment, do we cache it under a post object, or do we cache it under an author object?</p> <p>Working with data is the type of work that could be handled by a framework, and Relay is an attempt to innovate in that domain.</p> <ul> <li>Learning GraphQL and Relay by Samer Buna :pg 19</li> </ul>"},{"location":"testing/stubb/","title":"Stub","text":""},{"location":"testing/stubb/#understanding-mocking-and-stubb","title":"Understanding Mocking and Stubb","text":"<p>In unit testing, mocking and stubbing are techniques used to isolate the unit under test from its dependencies. This allows us to focus on testing the specific behaviour of the unit without relying in the external factors or complex setups.</p>"},{"location":"testing/stubb/#mocking","title":"Mocking","text":"<p>Mocking involves replaing real dependencies with fake implementations. This is particularly useful when dealing with external dependecies like network request, database interactions, or complex third-party libraries.</p>"},{"location":"testing/stubb/#stubs","title":"Stubs","text":"<p>Stubs are simplified implementations of dependencies that return predefined values or perform specific actions. Stubs are often used to control the behavior of dependencies and to isolate the unit under test.</p>"},{"location":"testing/stubb/#tools","title":"Tools","text":""},{"location":"testing/stubb/#msw-vs-nock-vs-jest-mocks","title":"\ud83c\udd9a MSW vs Nock vs Jest Mocks","text":"Feature MSW Nock Jest Mock Level Network-level HTTP module Function/module-level Browser Support \u2705 Yes (via Service Worker) \u274c Node only \u2705 Yes API Realism \u2705 High Medium \u274c Low GraphQL \u2705 Built-in support \u274c No \u274c Manual"},{"location":"testing/stubb/#expanded-comparison-msw-vs-nock-vs-jest-vs-sinon-vs-others","title":"\ud83d\udd0d Expanded Comparison: MSW vs Nock vs Jest vs Sinon vs Others","text":"Tool Type Main Use Case Works in Browser? Works in Node? Level of Mocking MSW API Mocking (Network) Mock REST/GraphQL at network level (realistic) \u2705 Yes \u2705 Yes Network-level Nock HTTP Mocking Mock Node.js <code>http</code>/<code>https</code> requests \u274c No \u2705 Yes Network-level (Node only) Jest Mocks Function/Module Mock Unit test JS/TS code by mocking functions/modules \u2705 Yes \u2705 Yes Code-level Sinon Spy/Stub/Mock Flexible mocking of any function or object \u2705 Yes \u2705 Yes Code-level TestDouble Mocking Lib Clean, readable test doubles (stub/mock/spy) \u2705 Yes \u2705 Yes Code-level Vitest Mocks Like Jest (for Vite) Jest-compatible mocking in Vite apps \u2705 Yes \u2705 Yes Code-level"},{"location":"testing/stubb/#tldr-which-to-choose","title":"\u2705 TL;DR \u2014 Which to Choose?","text":"<ul> <li>Use MSW if you want to mock API calls realistically (e.g., React apps, browser testing).</li> <li>Use Nock for mocking HTTP requests in Node.js (e.g., backend services).</li> <li>Use Jest mocks or Sinon to mock or spy on functions, classes, or modules.</li> <li>Use TestDouble if you prefer a clean, expressive syntax and TDD-friendly style.</li> </ul> <p>Would you like a practical example showing MSW + Jest + Sinon working together in one test suite?</p>"},{"location":"testing/stubb/#reference","title":"Reference","text":"<ul> <li>Level Up your Javascript by Victor Jayden</li> </ul>"},{"location":"testing/types/","title":"Types","text":""},{"location":"testing/types/#types-of-testing-in-web-applications","title":"Types of Testing in Web Applications","text":"<p>Here\u2019s a breakdown of the main testing types you\u2019ll encounter:</p>"},{"location":"testing/types/#1-unit-testing","title":"1. Unit Testing","text":"<ul> <li> <p>What it is: Tests individual functions, components, or modules in isolation (e.g., a React component or a utility function).</p> </li> <li> <p>Tools:</p> <ul> <li>Jest: A popular testing framework for JavaScript and React. It\u2019s often paired with React Testing Library.</li> <li>Vitest: A faster alternative to Jest, especially good with modern JS frameworks.</li> </ul> </li> <li> <p>When to use: For small, reusable pieces of code (e.g., a button component or a helper function).</p> </li> <li>Example: Testing if a function <code>add(2, 3)</code> returns <code>5</code>.</li> </ul> Example <ul> <li>What: Tests a single React component in isolation.</li> <li>Example: Testing a <code>Button</code> component.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <pre><code>// Button.js\nexport const Button = ({ label, onClick }) =&gt; (\n    &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;\n);\n\n// Button.test.js\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport { Button } from \"./Button\";\n\ntest(\"renders button and handles click\", () =&gt; {\n    const handleClick = jest.fn(); // Mock function to track clicks\n    render(&lt;Button label=\"Click me\" onClick={handleClick} /&gt;);\n\n    const button = screen.getByText(\"Click me\");\n    expect(button).toBeInTheDocument(); // Check if it renders\n\n    fireEvent.click(button); // Simulate click\n    expect(handleClick).toHaveBeenCalledTimes(1); // Check if click handler works\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code></li> </ul>"},{"location":"testing/types/#2-integration-testing","title":"2. Integration Testing","text":"<ul> <li>What it is: Tests how different parts of your app work together (e.g., a React component calling an API).</li> <li> <p>Tools:</p> <ul> <li>Jest + React Testing Library: For testing component interactions.</li> <li>Cypress (component testing): For testing how components integrate in a real browser-like environment.</li> </ul> </li> <li> <p>When to use: When you want to ensure modules or components collaborate correctly.</p> </li> <li>Example: Testing if a form submission triggers an API call and updates the UI.</li> </ul> Example <ul> <li>What: Tests how components work together, e.g., a form submitting data.</li> <li>Example: Testing a <code>Form</code> component that updates state.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <pre><code>// Form.js\nimport { useState } from 'react';\n\nexport const Form = ({ onSubmit }) =&gt; {\n    const [input, setInput] = useState('');\n    return (\n        &lt;form onSubmit={(e) =&gt; { e.preventDefault(); onSubmit(input); }}&gt;\n            &lt;input value={input} onChange={(e) =&gt; setInput(e.target.value)} /&gt;\n            &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\n// Form.test.js\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Form } from './Form';\n\ntest('form submits input value', () =&gt; {\n    const handleSubmit = jest.fn();\n    render(&lt;Form onSubmit={handleSubmit} /&gt;);\n\n    const input = screen.getByRole('textbox');\n    const button = screen.getByText('Submit');\n\n    fireEvent.change(input, { target: { value: 'Hello' } }); // Type in input\n    fireEvent.click(button); // Submit form\n\n    expect(handleSubmit).toHaveBeenCalledWith('Hello'); // Check if value is passed\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code></li> </ul>"},{"location":"testing/types/#3-end-to-end-e2e-testing","title":"3. End-to-End (E2E) Testing","text":"<ul> <li>What it is: Simulates real user scenarios across the entire app (e.g., logging in, navigating pages, submitting forms).</li> <li> <p>Tools:</p> <ul> <li>Cypress: Great for browser-based E2E testing, easy to set up.</li> <li>Playwright: A newer, powerful option that supports multiple browsers and is fast.</li> <li>Puppeteer: Good for headless browser testing, though less user-friendly than Cypress or Playwright.</li> </ul> </li> <li> <p>When to use: To verify the full flow of your app in a production-like environment.</p> </li> <li>Example: Testing the entire checkout process in an e-commerce app.</li> </ul> Example <ul> <li>What: Tests a full user flow in a browser-like environment.</li> <li>Example: Submitting a form and checking the result.</li> <li>Tools: Cypress.</li> </ul> <pre><code>// cypress/e2e/form.cy.js\ndescribe('Form Submission', () =&gt; {\n    it('submits form and shows success message', () =&gt; {\n        cy.visit('/'); // Visit your Next.js app\u2019s homepage\n        cy.get('input').type('Hello'); // Type into input\n        cy.get('button').contains('Submit').click(); // Click submit\n        cy.get('#success-message').should('contain', 'Submitted: Hello'); // Check result\n    });\n});\n</code></pre> <ul> <li> <p>Setup: Install Cypress (<code>npm install --save-dev cypress</code>), then run <code>npx cypress</code> open.</p> </li> <li> <p>App Code: Assumes a <code>Next.js</code> page with a form and a success message div.</p> </li> </ul>"},{"location":"testing/types/#4-snapshot-testing","title":"4. Snapshot Testing","text":"<ul> <li>What it is: Captures the rendered output of a React component and compares it to a saved \u201csnapshot\u201d to detect changes.</li> <li>Tools: Jest (with its built-in snapshot feature) + React Testing Library.</li> <li>When to use: To catch unintended UI changes in React components.</li> <li>Example: Ensuring a <code>&lt;Button /&gt;</code> component\u2019s HTML structure doesn\u2019t change unexpectedly.</li> </ul> Example <ul> <li>What: Captures a component\u2019s rendered output and compares it later.</li> <li>Example: Testing a <code>Button</code> component\u2019s structure.</li> <li>Tools: Jest.</li> </ul> <pre><code>// Button.js (same as above)\nexport const Button = ({ label }) =&gt; &lt;button&gt;{label}&lt;/button&gt;;\n\n// Button.test.js\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ntest('matches snapshot', () =&gt; {\n    const { asFragment } = render(&lt;Button label=\"Click me\" /&gt;);\n    expect(asFragment()).toMatchSnapshot(); // Creates/updates snapshot\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code> (First run creates a <code>__snapshots__</code> folder; subsequent runs compare against it.)</li> </ul>"},{"location":"testing/types/#5-visual-regression-testing","title":"5. Visual Regression Testing","text":"<ul> <li> <p>What it is: Checks for visual differences in the UI (e.g., layout shifts, color changes).</p> </li> <li> <p>Tools:</p> <ul> <li>Storybook + Chromatic: For component-level visual testing.</li> <li>Percy: Integrates with Cypress or Playwright for full-page visual checks.</li> </ul> </li> <li> <p>When to use: When UI consistency is critical.</p> </li> <li>Example: Verifying a redesigned button still looks correct across pages.</li> </ul> Example <ul> <li>What: Checks for visual changes in the UI.</li> <li>Example: Testing a button\u2019s appearance with Percy and Cypress.</li> <li>Tools: Cypress + Percy.</li> </ul> <pre><code>// cypress/e2e/button.cy.js\ndescribe('Button Visual Test', () =&gt; {\n    it('looks correct', () =&gt; {\n        cy.visit('/'); // Load page with button\n        cy.get('button').contains('Click me');\n        cy.percySnapshot('Button Default State'); // Takes a screenshot\n    });\n});\n</code></pre> <ul> <li>Setup: Install Percy (<code>npm install --save-dev @percy/cypress</code>), set up Percy token, run <code>npx cypress run</code> with Percy integration.</li> </ul>"},{"location":"testing/types/#6-performance-testing","title":"6. Performance Testing","text":"<ul> <li>What it is: Measures how fast and efficient your app is under load or stress.</li> <li> <p>Tools:</p> <ul> <li>Lighthouse: Built into Chrome DevTools, great for Next.js apps.</li> <li>WebPageTest: For detailed performance analysis.</li> </ul> </li> <li> <p>When to use: To optimize load times and responsiveness.</p> </li> <li>Example: Checking if your Next.js app\u2019s server-side rendering meets performance goals.</li> </ul> Example <ul> <li>What: Measures app performance metrics.</li> <li>Example: Using Lighthouse to audit a <code>Next.js</code> page.</li> <li>Tools: Lighthouse (via Chrome DevTools or CLI).</li> </ul> <pre><code># Install Lighthouse CLI\nnpm install -g lighthouse\n\n# Run Lighthouse on your local Next.js app\nlighthouse http://localhost:3000 --view\n</code></pre> <ul> <li> <p>Output: Generates a report with scores for performance, SEO, etc.</p> </li> <li> <p>App Code: Run your Next.js app locally (<code>npm run dev</code>) first.</p> </li> </ul>"},{"location":"testing/types/#7-accessibility-a11y-testing","title":"7. Accessibility (a11y) Testing","text":"<ul> <li> <p>What it is: Ensures your app is usable by people with disabilities.</p> </li> <li> <p>Tools:</p> <ul> <li>axe-core: Integrates with Jest or Cypress.</li> <li>Lighthouse: Includes an accessibility audit.</li> </ul> </li> <li> <p>When to use: To comply with standards like WCAG and improve inclusivity.</p> </li> <li> <p>Example: Testing if a form has proper ARIA labels.</p> </li> </ul> Example <ul> <li>What: Ensures the app is accessible.</li> <li>Example: Testing a form for accessibility issues.</li> <li>Tools: Jest + axe-core.</li> </ul> <pre><code>// Form.js (same as above)\n\n// Form.test.js\nimport { render, screen } from '@testing-library/react';\nimport { axe } from 'jest-axe';\nimport { Form } from './Form';\n\ntest('form is accessible', async () =&gt; {\n    const { container } = render(&lt;Form onSubmit={() =&gt; {}} /&gt;);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations(); // Fails if accessibility issues are found\n});\n</code></pre> <ul> <li>Setup: Install axe (<code>npm install --save-dev jest-axe</code>), run <code>npx jest</code>.</li> </ul>"},{"location":"testing/types/#8-manual-testing","title":"8. Manual Testing","text":"<ul> <li>What it is: Human-driven testing without automation, exploring the app for bugs or usability issues.</li> <li>Tools: None, just your browser and app.</li> <li>When to use: For exploratory testing or when automation isn\u2019t feasible yet.</li> <li>Example: Clicking through your app to see if anything breaks.</li> </ul> Example <ul> <li>What: Human exploration of the app.</li> <li>Example: Testing a form manually.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <p>Steps:</p> <ol> <li>Open your Next.js app in the browser (<code>npm run dev</code>).</li> <li>Go to the form page.</li> <li>Type \u201cHello\u201d in the input.</li> <li>Click \u201cSubmit.\u201d</li> <li>Verify a success message appears (e.g., \u201cSubmitted: Hello\u201d).</li> </ol> <p>Tools: Just your browser (e.g., Chrome).</p> Notes <ul> <li>Setup: For most automated tests, you\u2019ll need to install dependencies and configure your project (e.g., add Jest to Next.js via <code>next/jest</code>).</li> <li>Next.js: These examples work well with Next.js; adjust paths or imports as needed (e.g., <code>pages/</code> for E2E).</li> <li>Scaling: Start with unit tests, then add others based on your app\u2019s needs.</li> </ul>"},{"location":"vitest/overview/","title":"Overview","text":""},{"location":"vitest/overview/#overview","title":"Overview","text":"<p>Vitest (pronounced as \"veetest\") is a next generation testing framework powered by Vite.</p>"},{"location":"vitest/overview/#installation","title":"Installation","text":"npmpnpmyarn bash<pre><code>npm install -D vitest\n</code></pre> bash<pre><code>pnpm add -D vitest\n</code></pre> bash<pre><code>yarn add -D vitest\n</code></pre> Tip <p>Vitest requires <code>Vite &gt;=v5.0.0</code> and <code>Node &gt;=v18.0.0</code></p>"},{"location":"vitest/overview/#reference","title":"Reference","text":"<ul> <li>Vitest guide</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/frontend/","title":"Frontend","text":""},{"location":"blog/category/testing/","title":"Testing","text":""}]}