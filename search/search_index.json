{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Unit tests are great for peace of mind and reducing software errors. You should always make the time to test.</p> <p>The key difference in the test-driven development lifecycle is that before writing the feature code, a test is written.(1)</p> <ol> <li> <p>Initially, the test would be empty and will fail because the feature function does not exist yet. Now write a simple feature function, and the test will pass.</p> <p>Update the test with more checks. The test might fail. Update the feature function again, and the test will pass. Keep doing this until all the test cases are covered.</p> <p>In the end, you will have a function that is well-unit-tested. Do this for all features, and you will have a nearly bug-free code. Nearly bug-free because there are many other factors responsible for zero-defect software.</p> <ul> <li>Mastering Test-Driven Development with React by Ravi Kumar Gupta</li> </ul> </li> </ol>"},{"location":"#types-of-testing","title":"Types of Testing","text":""},{"location":"#js-event-loop","title":"JS Event Loop","text":"<ul> <li>\u2728\u267b\ufe0f JavaScript Visualized: Event Loop</li> </ul>"},{"location":"#js-event-loop-reference","title":"JS Event Loop Reference","text":"<ul> <li>Youtube: JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue</li> <li>Dev.to Blog: JavaScript Visualized: Event Loop </li> <li>Source: JavaScript Visualized: Event Loop, Web APIs, (Micro)task Queue</li> </ul>"},{"location":"#book","title":"Book","text":""},{"location":"#reference","title":"Reference","text":"<ul> <li>Top 11 JavaScript Testing Frameworks: Everything You Need to Know</li> <li> <p>JavaScript unit testing frameworks in 2024: A comparison</p> </li> <li> <p>How to write your first unit test in JavaScript</p> </li> <li> <p>JS Unit Testing Frameworks Comparison</p> </li> <li> <p>Book</p> </li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/","title":"Beginner's Guide: Switching from Jest to Vitest in React Projects","text":"","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#beginners-guide-switching-from-jest-to-vitest-in-react-projects","title":"Beginner's Guide: Switching from Jest to Vitest in React Projects","text":"<p>Testing is an essential part of building stable and maintainable React applications. If you've been using Jest, you're in good company\u2014it's been the default choice for years. But a new contender has been making waves: Vitest.</p> <p>In this post, we\u2019ll walk you through what Vitest is, why you might want to try it, and how to get started\u2014especially if you\u2019re coming from a Jest background.</p>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#what-is-vitest","title":"\ud83e\uddea What is Vitest?","text":"<p>Vitest is a blazing-fast unit test framework built on top of Vite. It supports ESM, is deeply integrated with the Vite dev server, and has Jest-compatible APIs\u2014making it super appealing for React developers looking for speed and simplicity.</p> <p>Key benefits of Vitest:</p> <ul> <li>\u26a1 Fast startup with Vite integration</li> <li>\ud83e\udde9 Works with ESM and TypeScript out of the box</li> <li>\ud83c\udfad Jest-like syntax and matchers</li> <li>\ud83e\udde0 Built-in mocking and snapshot support</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#why-switch-from-jest","title":"\ud83e\udd14 Why switch from Jest?","text":"<p>Jest is battle-tested, but it can feel slow\u2014especially in large projects. It uses a separate Node.js environment, which can lead to inconsistencies between your test and dev environments.</p> <p>Vitest, on the other hand:</p> <ul> <li>Shares the dev server with your Vite app (no more duplicated builds)</li> <li>Has near-instant feedback on file changes</li> <li>Offers a smoother developer experience in modern frontend stacks</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#getting-started-with-vitest-in-a-react-project","title":"\ud83d\ude80 Getting Started with Vitest in a React Project","text":"<p>Let\u2019s create a simple React app and set up Vitest. If you already have a Vite + React project, you can skip to step 3.</p>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#1-create-a-vite-react-app","title":"1. Create a Vite + React App","text":"<pre><code>npm create vite@latest my-react-vitest-app --template react\ncd my-react-vitest-app\nnpm install\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#2-install-vitest-and-react-testing-tools","title":"2. Install Vitest and React Testing Tools","text":"<pre><code>npm install -D vitest @testing-library/react @testing-library/jest-dom\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#3-configure-vitest","title":"3. Configure Vitest","text":"<p>Update <code>vite.config.ts</code> (or <code>.js</code>) to include the <code>test</code> config:</p> <pre><code>// vite.config.ts\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: \"jsdom\",\n    setupFiles: \"./src/setupTests.ts\",\n  },\n});\n</code></pre> <p>Create a setup file like <code>src/setupTests.ts</code>:</p> <pre><code>// src/setupTests.ts\nimport \"@testing-library/jest-dom\";\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#4-write-your-first-test","title":"4. Write Your First Test","text":"<pre><code>// src/components/Hello.test.tsx\nimport { render, screen } from \"@testing-library/react\";\nimport Hello from \"./Hello\";\n\ntest(\"renders hello message\", () =&gt; {\n  render(&lt;Hello name=\"React\" /&gt;);\n  expect(screen.getByText(\"Hello, React!\")).toBeInTheDocument();\n});\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#5-run-the-tests","title":"5. Run the Tests","text":"<pre><code>npx vitest run\n</code></pre> <p>Or run in watch mode:</p> <pre><code>npx vitest\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#jest-vs-vitest-syntax-comparison","title":"\u2705 Jest vs Vitest: Syntax Comparison","text":"Feature Jest Vitest Test function <code>test()</code> / <code>it()</code> <code>test()</code> / <code>it()</code> Assertions <code>expect().toBe()</code> <code>expect().toBe()</code> Setup file <code>setupFilesAfterEnv</code> in <code>jest.config</code> <code>setupFiles</code> in <code>vite.config</code> Mock functions <code>jest.fn()</code> <code>vi.fn()</code> Snapshot tests <code>expect(...).toMatchSnapshot()</code> <code>expect(...).toMatchSnapshot()</code> <p>You can even alias <code>vi</code> as <code>jest</code> if you want to port code quickly:</p> <pre><code>// Optional: alias vi to jest\nglobalThis.jest = vi;\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#final-thoughts","title":"\ud83e\udded Final Thoughts","text":"<p>Vitest is a modern alternative to Jest that fits naturally with Vite-powered projects. If you're already using Vite for React development, Vitest offers a seamless, fast, and familiar testing experience with a gentle learning curve.</p>","tags":["Personal"]},{"location":"blog/2025/05/25/beginners-guide-switching-from-jest-to-vitest-in-react-projects/#useful-resources","title":"\ud83d\udee0\ufe0f Useful Resources","text":"<ul> <li>Vitest Docs</li> <li>Testing Library for React</li> <li>Migrating from Jest to Vitest</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/","title":"Choosing Between Jest, Vitest, and React Testing Library","text":"","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#choosing-between-jest-vitest-and-react-testing-library","title":"Choosing Between Jest, Vitest, and React Testing Library","text":"<p>When you're starting out with testing in JavaScript or React, you'll quickly come across three major tools: Jest, Vitest, and React Testing Library. While they often appear together, they serve different purposes. In this post, we'll break down what each one does, when to use them, and which combination is best for your project.</p> <p>\ud83e\uddea Beginner-friendly guide to testing frameworks for React projects</p>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#overview","title":"\ud83d\udd0d Overview","text":"Tool Type Purpose Jest Test Runner Run JavaScript/React tests Vitest Test Runner Fast, modern alternative for Vite users React Testing Library Component Testing Test React components from a user's view","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#jest","title":"\u2705 Jest","text":"<p>Jest is the most widely used testing framework in the JavaScript world. It comes pre-configured with tools like Create React App (CRA).</p> <p>Features:</p> <ul> <li>Built-in test runner and assertion library</li> <li>Snapshot testing support</li> <li>Mocking and spies</li> <li>Works with React, Node.js, and TypeScript</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re using Create React App</li> <li>Your project does not use Vite</li> <li>You want a mature, stable testing setup</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#vitest","title":"\u26a1 Vitest","text":"<p>Vitest is a modern alternative to Jest, built specifically for the Vite ecosystem. It\u2019s designed for speed and seamless Vite integration.</p> <p>Features:</p> <ul> <li>Lightning-fast test runs</li> <li>Uses native ES modules</li> <li>Shares config with your <code>vite.config.ts</code></li> <li>Compatible with Jest-style syntax (<code>describe</code>, <code>expect</code>, etc.)</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re using Vite with React or Vue</li> <li>You want faster test performance</li> <li>You prefer modern tools with better DX</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#react-testing-library","title":"\ud83e\uddea React Testing Library","text":"<p>React Testing Library (RTL) is not a test runner. It's a helper library that lets you test React components as a user would interact with them.</p> <p>Features:</p> <ul> <li>Encourages good testing practices</li> <li>Focuses on accessibility and user interactions</li> <li>Works with both Jest and Vitest</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re testing React components</li> <li>You care about testing UI like a user would</li> <li>You\u2019re already using Jest or Vitest</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#should-you-use-jest-or-vitest","title":"\u2694\ufe0f Should You Use Jest or Vitest?","text":"<p>You should only use one, not both.</p> Your Project Uses Use This Create React App \u2705 Jest Vite + React \u2705 Vitest Legacy Node project \u2705 Jest New, modern React app \u2705 Vitest","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#final-recommendation-for-beginners","title":"\u2705 Final Recommendation for Beginners","text":"You Are Using Install These Create React App <code>jest</code> (comes with CRA), <code>@testing-library/react</code> Vite + React <code>vitest</code>, <code>@testing-library/react</code>, <code>jsdom</code>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#sample-vitest-react-testing-library-setup","title":"\ud83d\udee0\ufe0f Sample Vitest + React Testing Library Setup","text":"<p>Install:</p> <pre><code>npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom\n</code></pre> <p>In <code>vite.config.ts</code>:</p> <pre><code>import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: './setupTests.ts',\n  },\n})\n</code></pre> <p>In <code>setupTests.ts</code>:</p> <pre><code>import '@testing-library/jest-dom'\n</code></pre>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#summary","title":"\ud83d\udccc Summary","text":"<ul> <li>Use Jest or Vitest \u2014 not both.</li> <li>Pair either one with React Testing Library for component testing.</li> <li>Use Jest for CRA, Vitest for Vite.</li> <li>Focus on writing tests that reflect real user behavior.</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/","title":"Understanding the Difference Between jsdom and @testing-library/jest-dom","text":"","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#understanding-the-difference-between-jsdom-and-testing-libraryjest-dom","title":"Understanding the Difference Between <code>jsdom</code> and <code>@testing-library/jest-dom</code>","text":"<p>Yes, exactly \u2014 <code>jsdom</code> and <code>@testing-library/jest-dom</code> are completely different things, but they often work together in testing setups.</p> <p>vitest: The testing framework.</p> Installation<pre><code>npm install --save-dev vitest\n</code></pre> <p>After installing <code>vitest</code>, we will have to add a script to our <code>package.json</code> file to run our test.</p> package.json<pre><code>{\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n</code></pre> <p>By default, Vitest requires you to import basic functions like describe and expect. To make these available as globals, you\u2019ll need to make a couple of configuration tweaks. (1)</p> <ol> <li> <p>First, update <code>vite.config.tsx</code> to use the <code>defineConfig</code> function from <code>vitest/config</code>, and enable the <code>test.globals</code> flag:</p> vite.config.ts<pre><code>import { defineConfig } from \"vitest/config\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n  },\n});\n</code></pre> <p>Test Drivern React, Second Edition by Trevor Burnham</p> </li> </ol>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#what-is-jsdom","title":"What is <code>jsdom</code>?","text":"<ul> <li><code>jsdom</code> is a JavaScript-based implementation of the browser\u2019s DOM.</li> <li>It runs inside Node.js to simulate a real browser environment.</li> <li>Because Node.js does not have a native DOM, <code>jsdom</code> provides essential browser APIs like <code>window</code>, <code>document</code>, and <code>HTMLElement</code>.</li> <li>This environment lets you render UI components (React, Vue, etc.) and interact with the DOM during tests.</li> <li>Without <code>jsdom</code>, you can\u2019t test UI code that depends on the DOM in Node.js.</li> </ul> Installation<pre><code>npm install jsdom --save-dev\n</code></pre> <p>After installing <code>jsdom</code>, we have to include <code>jsdom</code> in the Vite configuration file, which you can find at the root of your React project <code>vite.config.js</code></p> <pre><code>import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    // \ud83d\udc4b add the line below to add jsdom to vite\n    environment: \"jsdom\",\n  },\n});\n</code></pre>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#what-is-testing-libraryjest-dom","title":"What is <code>@testing-library/jest-dom</code>?","text":"<ul> <li><code>@testing-library/jest-dom</code> is a library that adds custom Jest matchers for asserting on DOM nodes.</li> <li> <p>Examples of matchers it provides:</p> <ul> <li><code>.toBeInTheDocument()</code></li> <li><code>.toHaveTextContent()</code></li> <li><code>.toHaveAttribute()</code></li> <li><code>.toHaveClass()</code></li> </ul> </li> <li> <p>These matchers make your test assertions more readable and expressive.</p> </li> <li>However, since they assert on DOM elements, they require a DOM environment to work.</li> </ul> Installation<pre><code>npm install @testing-library/react @testing-library/jest-dom --save-dev\n</code></pre> Explanation <ul> <li><code>@testing-library/react</code>: Provides utilities to test React components.</li> <li><code>@testing-library/jest-dom</code>: Adds custom matchers to Jest and Vitest for DOM node assertions.</li> <li><code>@testing-library/user-event</code>: Simulates user interactions with the DOM.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#how-do-jsdom-and-jest-dom-work-together","title":"How Do <code>jsdom</code> and <code>jest-dom</code> Work Together?","text":"<code>jsdom</code> <code>@testing-library/jest-dom</code> Simulates the browser\u2019s DOM Provides expressive matchers for testing DOM Enables rendering and DOM APIs Makes assertions on DOM nodes easier Used as a test environment in Node Extends Jest or Vitest assertion library In short: <ul> <li><code>jsdom</code> creates the DOM environment your components run in.</li> <li><code>jest-dom</code> provides nicer assertions you use to test the DOM elements in that environment.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#do-you-always-need-both","title":"Do You Always Need Both?","text":"<ul> <li>No, but often yes!</li> <li>If you test pure functions or logic without DOM, you don\u2019t need <code>jsdom</code> or <code>jest-dom</code>.</li> <li>If you test UI components or DOM manipulation, you need <code>jsdom</code> to simulate the DOM and <code>jest-dom</code> to write readable assertions.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#example-vitest-setup","title":"Example Vitest Setup","text":"<pre><code>// vitest.config.ts\nimport { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    environment: \"jsdom\", // enable jsdom environment\n    setupFiles: \"./setupTests.ts\",\n  },\n});\n</code></pre> <pre><code>// setupTests.ts\nimport \"@testing-library/jest-dom\"; // import jest-dom matchers\n</code></pre>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#summary","title":"Summary","text":"Tool Purpose <code>jsdom</code> Simulates browser DOM in Node.js tests <code>@testing-library/jest-dom</code> Adds readable matchers to assert on DOM nodes <p>Using both together helps you write effective and easy-to-understand frontend tests.</p>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#reference","title":"Reference","text":"<ul> <li>Medium: Vitest with React Testing Library In React(created with Vite)</li> <li>Vitest with React Testing Library</li> <li>Testing React Applications with Vitest: A Comprehensive Guide </li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/","title":"Controlled vs Uncontrolled Components in React","text":"","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#controlled-vs-uncontrolled-components-in-react","title":"Controlled vs Uncontrolled Components in React","text":"<p>React components are often described as controlled or uncontrolled depending on how their <code>state</code> is managed. While this terminology is usually applied to form elements, the concept is useful across any kind of component.</p> <pre><code>\ud83d\udd01 General Concept (Outside of Forms)\n\nImagine a component that shows a toggle between \u201cOn\u201d and \u201cOff\u201d:\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#what-do-controlled-and-uncontrolled-mean","title":"\ud83e\udde0 What Do Controlled and Uncontrolled Mean?","text":"<ul> <li>Controlled Component: The parent component fully manages the <code>state</code> and passes it as <code>props</code>.</li> <li>Uncontrolled Component: The component maintains its own internal state.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#controlled-example-toggle-buttonnon-form","title":"\u2705 Controlled Example (Toggle Button)/(Non-form)","text":"<p>In a controlled component, the parent holds the state and controls the component behavior.</p> <pre><code>function Toggle({ isOn, onToggle }) {\n  return &lt;button onClick={onToggle}&gt;{isOn ? \"On\" : \"Off\"}&lt;/button&gt;;\n}\n\nfunction App() {\n  const [isOn, setIsOn] = useState(false);\n\n  return &lt;Toggle isOn={isOn} onToggle={() =&gt; setIsOn(!isOn)} /&gt;;\n}\n</code></pre> <ul> <li><code>Toggle</code> doesn't own its state.</li> <li>Parent (<code>App</code>) is the single source of truth.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#uncontrolled-example-toggle-buttonnon-form","title":"\u274c Uncontrolled Example (Toggle Button)/(Non-form)","text":"<p>In an uncontrolled component, the component manages its own state:</p> <pre><code>function Toggle() {\n  const [isOn, setIsOn] = useState(false);\n\n  return &lt;button onClick={() =&gt; setIsOn(!isOn)}&gt;{isOn ? \"On\" : \"Off\"}&lt;/button&gt;;\n}\n</code></pre> <ul> <li><code>Toggle</code> is self-contained.</li> <li>Parent has no visibility or control over state.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#hybrid-pattern","title":"\ud83e\udde9 Hybrid Pattern","text":"<p>Some components allow both controlled and uncontrolled usage:</p> <pre><code>function Toggle({ isOn: controlledIsOn, onToggle }) {\n  const [internalIsOn, setInternalIsOn] = useState(false);\n  const isControlled = controlledIsOn !== undefined;\n  const isOn = isControlled ? controlledIsOn : internalIsOn;\n\n  function handleClick() {\n    if (isControlled) {\n      onToggle?.();\n    } else {\n      setInternalIsOn(!internalIsOn);\n    }\n  }\n\n  return &lt;button onClick={handleClick}&gt;{isOn ? \"On\" : \"Off\"}&lt;/button&gt;;\n}\n</code></pre> <ul> <li>Works in both controlled and uncontrolled modes.</li> <li>Often used in UI libraries (like Material-UI).</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#when-to-use-what","title":"\ud83e\udd14 When to Use What?","text":"Scenario Use Controlled Use Uncontrolled Parent needs control \u2705 \u274c Internal logic is isolated \u274c \u2705 Component used in library/API \u2705 / Hybrid \u2705 Simple use without customization \u274c \u2705","tags":["Personal"]},{"location":"blog/2025/05/23/controlled-vs-uncontrolled-components-in-react/#summary","title":"\ud83e\udded Summary","text":"<ul> <li> <p>Controlled: Parent manages all state and logic.</p> </li> <li> <p>Uncontrolled: Component manages itself.</p> </li> <li> <p>Use controlled when you need predictability and coordination between components.</p> </li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/","title":"Controlled vs Uncontrolled Form Components in React","text":"","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#controlled-vs-uncontrolled-form-components-in-react","title":"Controlled vs Uncontrolled Form Components in React","text":"<p>One of the most fundamental concepts in building forms with React is the difference between controlled and uncontrolled components. Understanding this difference helps you decide how to handle form input in a way that best fits your application's needs.</p>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#what-are-controlled-and-uncontrolled-components","title":"\ud83d\udccc What Are Controlled and Uncontrolled Components?","text":"","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#controlled-form-component","title":"\u2705 Controlled Form Component","text":"<p>A controlled component is a form element (like <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, or <code>&lt;select&gt;</code>) whose value is controlled by React state. Every change in the input is handled through a React <code>onChange</code> handler that updates the component\u2019s state.</p> Quote <ul> <li>The input\u2019s value comes from the component\u2019s <code>state</code>.</li> <li>Every change in the input is handled by an <code>onChange</code> handler that updates the <code>state</code>.</li> </ul> <pre><code>function ControlledForm() {\n  const [email, setEmail] = useState(\"\");\n\n  const handleSubmit = (e) =&gt; {\n    e.preventDefault();\n    console.log(\"Submitted email:\", email);\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input\n        type=\"email\"\n        value={email}\n        onChange={(e) =&gt; setEmail(e.target.value)}\n      /&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> <ul> <li>React is the single source of truth for the input.</li> <li>Useful for validation, formatting, or conditional rendering.</li> </ul> Tip <ul> <li>\ud83d\udfe2 React controls the input.</li> <li>\ud83d\udfe2 State is the single source of truth.</li> <li>\ud83d\udfe2 Easy to validate, format, and manipulate data dynamically.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#uncontrolled-form-component","title":"\u274c Uncontrolled Form Component","text":"<p>An uncontrolled component is one where the form input keeps its own internal state, and you access its value using a <code>ref</code>.</p> <pre><code>function UncontrolledForm() {\n  const emailRef = useRef();\n\n  const handleSubmit = (e) =&gt; {\n    e.preventDefault();\n    console.log(\"Submitted email:\", emailRef.current.value);\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input type=\"email\" ref={emailRef} /&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> <ul> <li>The DOM maintains the input's value.</li> <li>Good for simple forms or when you don\u2019t need React to track state.</li> </ul> Note <ul> <li>\ud83d\udd35 React does not control the input.</li> <li>\ud83d\udd35 Good for quick or simple forms.</li> <li>\ud83d\udd35 Harder to perform validation or pre-fill logic.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#feature-comparison-table","title":"\ud83d\udcdd Feature Comparison Table","text":"Feature Controlled Uncontrolled State Management React state DOM via <code>ref</code> Value Binding <code>value</code> + <code>onChange</code> <code>defaultValue</code> Validation Easy Requires manual handling Real-time Feedback \u2705 \u274c Resetting Form Update state Use DOM manipulation Initial Values Set via state Use <code>defaultValue</code> prop Use Case Dynamic, interactive forms Simple, static forms","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#when-to-use-which","title":"\ud83e\udded When to Use Which?","text":"Scenario Use Controlled Use Uncontrolled Real-time validation needed \u2705 \u274c Pre-fill values dynamically \u2705 \u274c Simple, static form \u274c \u2705 Form input must be synced with React state \u2705 \u274c Minimal logic on form fields \u274c \u2705 Input behavior or formatting must be customized \u2705 \u274c Performance critical (many uncontrolled fields) \u274c \u2705 Third-party integration / uncontrolled data \u274c \u2705 \u2705 Use Controlled Components When: <ul> <li>You need tight control over form input values.</li> <li>You want to validate or transform input as users type.</li> <li>You're working with dynamic forms (fields show/hide, change rules).</li> <li>You need to sync input values with state, props, or other logic.</li> </ul> \ud83d\udd35 Use Uncontrolled Components When: <ul> <li>You need a quick and simple form.</li> <li>You're building a form that submits once and forgets.</li> <li>You prefer working with refs and DOM elements directly.</li> <li>You don\u2019t need to interact with the form data until submission.</li> <li>Performance is more important than flexibility (e.g., large forms).</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#bonus-hybrid-forms","title":"\ud83e\udde9 Bonus: Hybrid Forms","text":"<p>Some forms use a hybrid approach, combining both controlled and uncontrolled inputs depending on the field.</p> <p>Example: Use controlled inputs for fields with validation, and uncontrolled for optional fields where performance is a concern.</p>","tags":["Personal"]},{"location":"blog/2025/05/24/controlled-vs-uncontrolled-form-components-in-react/#conclusion","title":"\ud83c\udfaf Conclusion","text":"<ul> <li> <p>Use controlled components for flexibility, validation, and real-time interactivity.</p> </li> <li> <p>Use uncontrolled components for simplicity and performance when you don't need to interact with the input until submission.</p> </li> <li> <p>Understanding when to use each helps you build cleaner, more maintainable forms in React.</p> </li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/","title":"\ud83e\uddea Testing in React: Vitest, Jest &amp; React Testing Library Explained","text":"","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#testing-in-react-vitest-jest-react-testing-library-explained","title":"\ud83e\uddea Testing in React: Vitest, Jest &amp; React Testing Library Explained","text":"<p>Testing in modern React apps can be confusing when you're not sure which tool does what. This blog post explains the roles of Vitest, Jest, and React Testing Library (RTL) \u2014 and how to use them effectively for unit testing, logic, and UI behavior.</p> <p>Both Vitest and Jest are JavaScript testing frameworks, mainly used for unit and integration testing.</p> Success <ul> <li>Vitest/Jest = The test runners.</li> <li>React Testing Library = Library to test React component behavior.</li> <li>You often use both together to test React apps effectively.</li> </ul> <p>To test logic, functions, unit tests, async code, etc., you mainly use Vitest or Jest \u2014 not React Testing Library, since RTL is focused on React UI behavior.</p>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#whats-the-difference","title":"\ud83d\udd0d What's the Difference?","text":"<p>Vitest vs Jest</p> Feature Vitest Jest Test runner \u2705 Yes \u2705 Yes Speed \ud83d\ude80 Fast with Vite \ud83d\udc22 Slower for large projects TypeScript support \ud83e\udde0 Excellent \u2705 Good Vite Integration \ud83d\udd25 Built-in \u274c Manual setup required Community/Ecosystem \ud83c\udf31 Growing \ud83c\udf33 Mature <p>Use Vitest for Vite-based projects, and Jest for broader or legacy setups.</p>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#what-does-react-testing-library-do","title":"\ud83e\uddea What Does React Testing Library Do?","text":"<p>React Testing Library does not run tests \u2014 it helps you test how users interact with the UI.</p> <p>You can use RTL with either Vitest or Jest. It focuses on:</p> <ul> <li>Rendering components</li> <li>Querying DOM elements</li> <li>Simulating user actions</li> <li>Verifying visible behavior</li> </ul>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#testing-examples","title":"\ud83d\udee0\ufe0f Testing Examples","text":"","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#1-testing-logic-unit-test","title":"\u2705 1. Testing Logic (Unit Test)","text":"<pre><code>// utils/calc.js\nexport function add(a, b) {\n  return a + b;\n}\n</code></pre> <pre><code>// calc.test.js\nimport { describe, it, expect } from \"vitest\";\nimport { add } from \"./calc\";\n\ndescribe(\"add\", () =&gt; {\n  it(\"adds two numbers\", () =&gt; {\n    expect(add(2, 3)).toBe(5);\n  });\n});\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#2-testing-async-functions-like-api-calls-or-timers","title":"\u2705 2. Testing Async Functions (like API calls or timers)","text":"<pre><code>// utils/fetchData.js\nexport async function fetchData() {\n  const res = await fetch(\"/api/data\");\n  return res.json();\n}\n</code></pre> <pre><code>// fetchData.test.js\nimport { vi, describe, it, expect } from \"vitest\";\n\nglobal.fetch = vi.fn(() =&gt;\n  Promise.resolve({\n    json: () =&gt; Promise.resolve({ name: \"Test\" }),\n  })\n);\n\nimport { fetchData } from \"./fetchData\";\n\ndescribe(\"fetchData\", () =&gt; {\n  it(\"returns mocked data\", async () =&gt; {\n    const data = await fetchData();\n    expect(data).toEqual({ name: \"Test\" });\n  });\n});\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#3-testing-react-component-ui","title":"\u2705 3. Testing React Component (UI)","text":"<pre><code>// MyComponent.jsx\nexport default function MyComponent() {\n  return &lt;h1&gt;Hello World&lt;/h1&gt;;\n}\n</code></pre> <pre><code>// MyComponent.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { describe, it, expect } from \"vitest\";\nimport MyComponent from \"./MyComponent\";\n\ndescribe(\"MyComponent\", () =&gt; {\n  it(\"renders a message\", () =&gt; {\n    render(&lt;MyComponent /&gt;);\n    expect(screen.getByText(/hello world/i)).toBeInTheDocument();\n  });\n});\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#testing-logic-inside-react-components","title":"\u2705 Testing Logic Inside React Components","text":"<p>You still use Vitest, but for logic-only parts (e.g., utility functions, custom hooks, state management functions), you don\u2019t need React Testing Library.</p> <p>Example: Testing a custom hook</p> <pre><code>// hooks/useCounter.js\nimport { useState } from \"react\";\n\nexport function useCounter() {\n  const [count, setCount] = useState(0);\n  const increment = () =&gt; setCount((c) =&gt; c + 1);\n  return { count, increment };\n}\n</code></pre> <pre><code>// hooks/useCounter.test.js\nimport { renderHook, act } from \"@testing-library/react\";\nimport { useCounter } from \"./useCounter\";\n\ndescribe(\"useCounter\", () =&gt; {\n  it(\"increments the counter\", () =&gt; {\n    const { result } = renderHook(() =&gt; useCounter());\n    act(() =&gt; {\n      result.current.increment();\n    });\n    expect(result.current.count).toBe(1);\n  });\n});\n</code></pre> <p>\ud83d\udee0\ufe0f <code>renderHook</code> is part of<code>@testing-library/react-hooks</code> or comes from the main RTL in newer versions.</p>","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#summary","title":"\ud83c\udfaf Summary","text":"Test Type Tool(s) Purpose Unit tests Vitest / Jest Pure logic, math, utilities Async functions Vitest / Jest API calls, async logic UI components Vitest / Jest + RTL React rendering and behavior Custom Hooks RTL <code>renderHook</code> + Vitest Hook logic, state behavior <p>&amp;</p> Type of Test Tools Used Example Pure Logic Vitest / Jest Math functions, string utilities Async Code Vitest / Jest + <code>vi.mock</code> API calls, delays Component UI Vitest / Jest + RTL Rendering, user interaction Custom Hooks RTL <code>renderHook</code> + Vitest State logic in hooks","tags":["Personal"]},{"location":"blog/2025/05/26/-testing-in-react-vitest-jest--react-testing-library-explained/#final-thoughts","title":"\ud83d\udd1a Final Thoughts","text":"<p>Use Vitest if you're using Vite. Use Jest if you're not. Use React Testing Library to test what the user sees and does. Together, they help you write confident, maintainable, and effective tests for your React app.</p>","tags":["Personal"]},{"location":"testing/developer-vs-qa/","title":"Dev vs QA Role","text":""},{"location":"testing/developer-vs-qa/#developer-vs-qa-role-in-testing","title":"Developer vs QA role in testing","text":"<p>In React development, the responsibility for writing unit tests, integration tests, and end-to-end (E2E) tests can vary depending on the team's structure and workflow. However, here is a general breakdown:</p>"},{"location":"testing/developer-vs-qa/#developers-role","title":"Developer's Role","text":"<p>React developers are typically responsible for writing unit tests and integration tests:</p> <ul> <li> <p>Unit Tests: These test individual components in isolation to ensure they function as expected (e.g., testing button clicks or state changes). Developers often use tools like Jest and React Testing Library for these tests.</p> </li> <li> <p>Integration Tests: These verify how multiple components interact with each other, ensuring proper functionality when components work together. Developers usually handle these tests as part of their coding workflow.</p> </li> </ul>"},{"location":"testing/developer-vs-qa/#qa-engineers-role","title":"QA Engineer's Role","text":"<p>Quality Assurance (QA) engineers focus more on end-to-end (E2E) testing and overall application quality:</p> <ul> <li> <p>E2E Tests: These simulate real user behavior across the entire application to ensure it works as intended in real-world scenarios. QA engineers typically design and execute these tests using tools like Cypress or Selenium.</p> </li> <li> <p>QA engineers also document testing phases, report bugs, and collaborate with developers to troubleshoot issues.</p> </li> </ul>"},{"location":"testing/developer-vs-qa/#shared-responsibility","title":"Shared Responsibility","text":"<p>In modern DevOps environments, testing responsibilities are often shared:</p> <ul> <li> <p>Developers are involved in early-stage testing to catch bugs during development.</p> </li> <li> <p>QA engineers ensure the application meets defined quality standards before release.</p> </li> </ul> <p>As a React developer, you should focus on unit and integration tests but may occasionally contribute to E2E testing, especially in smaller teams without dedicated QA personnel.</p> <ul> <li>Test behaviour, not the implementation</li> <li>Refactoring shouldn't break tests</li> </ul> <p>by - What I've Learned About Testing React Apps - Unit Tests </p>"},{"location":"testing/developer-vs-qa/#reference","title":"Reference","text":"<ul> <li>How To Write Integration Tests With Jest And React Testing Library</li> <li>React Testing: How to test React components?</li> <li>Guide to Hiring a React Developer with Testing and QA Skills</li> <li> <p>What I've Learned About Testing React Apps - Unit Tests</p> </li> <li> <p>Understanding the Roles in Quality Assurance</p> </li> <li>QA Tester job description</li> <li> <p>What Is a QA Tester?</p> </li> <li> <p>What is E2E? A guide to end-to-end testing</p> </li> </ul>"},{"location":"testing/intro/","title":"Overview","text":""},{"location":"testing/intro/#testing","title":"Testing","text":"<p>Testing is a crucial part of web application development, ensuring your app works as expected, is reliable, and provides a good user experience. Since you\u2019ve built applications with JavaScript, React, and Next.js but haven\u2019t done testing yet, I\u2019ll walk you through the types of testing commonly used in web applications, explain where to start, and address whether you should test first or later.</p> <p></p> <p></p>"},{"location":"testing/intro/#starting","title":"Starting","text":"<p>Deciding where to start with testing or which type is \"most important\" depends on your goals, your app\u2019s current state, and your experience level. Since you\u2019ve built an app with JavaScript, React, and Next.js but haven\u2019t done any testing yet, I\u2019ll break this down to help you choose.</p> Where Should You Start? <p>For someone new to testing with an existing app, Unit Testing is the best starting point. Here\u2019s why:</p> <ul> <li>Ease of Learning: Unit tests focus on small, isolated pieces (e.g., a single React component or function), making them simpler to understand and write compared to broader tests like E2E.</li> <li>Quick Feedback: They run fast and give immediate results, helping you build confidence in testing.</li> <li>Foundation: Mastering unit testing sets you up to tackle more complex types later (e.g., integration or E2E).</li> <li>Practical for Your Stack: React and Next.js are component-based, so unit testing aligns naturally with your codebase.</li> </ul> <p>Starting Example: Use Jest and React Testing Library to test a simple component (like the <code>Button</code> example from earlier). It\u2019s low effort to set up and gives you a tangible win.</p> Which Testing Type is Most Important? <p>\"Most important\" varies by context, but here\u2019s how to think about it:</p> <ol> <li> <p>Unit Testing</p> <ul> <li>Importance: High for catching bugs early in individual pieces of code. It\u2019s the backbone of a solid test suite.</li> <li>Why: Prevents small errors from snowballing. For example, ensuring a button\u2019s click handler works saves headaches later.</li> <li>When it\u2019s critical: For apps with lots of reusable logic or components (common in React/Next.js).</li> </ul> </li> <li> <p>Integration Testing</p> <ul> <li>Importance: High if your app relies on components working together (e.g., forms, API calls, state management).</li> <li>Why: Catches issues unit tests miss, like a form not passing data correctly to a parent component.</li> <li>When it\u2019s critical: If your app has complex interactions between parts.</li> </ul> </li> <li> <p>End-to-End (E2E) Testing</p> <ul> <li>Importance: Very high for ensuring the app works as a whole from a user\u2019s perspective.</li> <li>Why: Validates real-world flows (e.g., login \u2192 dashboard \u2192 logout). It\u2019s the closest to how users experience your app.</li> <li>When it\u2019s critical: For production apps where user experience and reliability are non-negotiable (e.g., e-commerce, SaaS).</li> </ul> </li> <li> <p>Other Types</p> <ul> <li>Snapshot: Useful for UI consistency but less critical early on.</li> <li>Visual Regression: Important for design-heavy apps, less so for functionality.</li> <li>Performance: Vital for user retention but can wait until core functionality is tested.</li> <li>Accessibility: Essential for inclusivity and compliance, but you can layer it in after basics.</li> <li>Manual: Good for exploration, but automation is more scalable.</li> </ul> </li> </ol> Recommendation <ul> <li>Start with Unit Testing: It\u2019s the most approachable and gives you a strong base. Set up Jest and React Testing Library, then test a few key components (e.g., a button, a form input). This builds your testing skills without overwhelming you.</li> <li>Most Important Long-Term: E2E Testing often becomes the most critical as your app grows because it ensures the entire system works for users. However, it\u2019s harder to start with due to setup complexity (e.g., Cypress) and requires a stable app to test effectively.</li> </ul>"},{"location":"testing/intro/#practical-plan","title":"Practical Plan","text":"<ol> <li> <p>Day 1: Install Jest (<code>npm install --save-dev jest</code>) and React Testing Library (<code>npm install --save-dev @testing-library/react</code>), then write a unit test for a component you\u2019ve already built. Example:</p> <pre><code>test(\"button renders\", () =&gt; {\n  render(&lt;Button label=\"Click me\" /&gt;);\n  expect(screen.getByText(\"Click me\")).toBeInTheDocument();\n});\n</code></pre> </li> <li> <p>Next Step: After a few unit tests, try an integration test for a component group (e.g., a form with a submit button).</p> </li> <li> <p>Later: Add E2E testing with Cypress once you\u2019re comfortable, focusing on key user flows.</p> </li> </ol> Why Not Start Elsewhere? <ul> <li>E2E: Too complex for a beginner; better after you\u2019ve tested smaller pieces.</li> <li>Performance/Accessibility: Important but secondary until functionality is solid.</li> <li>Manual: Useful now, but automation (starting with unit tests) scales better.</li> </ul> <p>Conclusion: Start with unit testing for its simplicity and immediate value. Long-term, E2E testing might be the most important for your app\u2019s success, but build up to it. Let me know if you need help setting up that first unit test!</p>"},{"location":"testing/react/","title":"React","text":""},{"location":"testing/react/#introducing-jest","title":"Introducing Jest","text":"<p>Jest is a test framework developed by Meta (n\u00e9e Facebook). Thanks to its rich feature set and solid performance, it\u2019s become the most popular library for testing JavaScript code in recent years.</p> Jest vs. Vitest <p>This chapter introduces you to testing with Jest, due to its popularity and ease of setup. However, later chapters will use Vitest, a Jest alternative that offers even faster performance when used in tandem with the Vite build tool. Vitest is designed for compatibility with tests written for Jest, so rest assured that the knowledge you pick up in this chapter will carry over!</p> <p>Unlike its forerunners, which expect to run in a browser environment, Jest runs in a Node process.</p>"},{"location":"testing/react/#adding-jest-as-a-dependency","title":"Adding Jest as a Dependency","text":"<p>Use npm to install the jest package:</p> <pre><code>$ npm install --save-dev jest@29.4.3\n</code></pre> <pre><code>// package.json\n{\n    ...\n    \"devDependencies\": {\n        \"jest\": \"^29.4.3\"\n    }\n}\n</code></pre> What Does the Caret (^) Before Version Numbers Mean? <p>By default, npm lists dependencies in <code>package.json</code> with a caret (<code>^</code>). The caret creates a version range that allows for minor updates and patches. So, <code>jest@^29.4.3</code> includes any version of <code>jest</code> from version <code>29.4.3</code> up to, but not including, <code>30.0.0</code>. According to <code>semver</code> principles, newer versions in that range should be backward compatible because package authors should bump the major version when making any breaking change. But be warned\u2014package authors often ignore semver principles!</p> <p>Fortunately, the other file <code>npm</code> created, <code>package-lock.json</code>, stores the exact version that was installed. As long as that lockfile is preserved, anyone who installs the project will get the exact same version of <code>jest</code> that you did. Put another way, <code>npm install</code> gives <code>package-lock.json</code> precedence over <code>package.json</code>. To install the latest version allowed by <code>package.json</code>, use the <code>npm update</code> command.</p> <p>Now Jest is installed and ready for you to use. However, it\u2019s in the project\u2019s <code>node_modules</code>, not on your PATH. To run it, you\u2019ll need to call on another tool\u2014npx.</p>"},{"location":"testing/react/#running-project-scripts-with-npm","title":"Running Project Scripts with npm","text":"<pre><code>$ npx jest --version\n29.4.3\n</code></pre> <p>The test script is special to npm; you can execute it with either <code>npm run test</code> or just <code>npm test</code>. You should see the same output that you got with npx jest:</p> <pre><code>$ npm test\n</code></pre> <p>No tests found, exiting with code 1</p>"},{"location":"testing/react/#writing-a-test","title":"Writing a Test","text":"<p>Time for your first test! Create a file called greeting.test.js:</p> <pre><code>// greeting.test.js\nconst greeting = (guest) =&gt; `Hello, ${guest}!`;\n\ndescribe(\"greeting()\", () =&gt; {\n  it(\"says hello\", () =&gt; {\n    expect(greeting(\"Jest\")).toBe(\"Hello, Jest!\");\n  });\n});\n</code></pre> <ol> <li> <p><code>describe()</code> declares a test suite, which is a grouping of tests. Its first argument is a name, and the second is a function containing one or more tests.</p> </li> <li> <p><code>it()</code> declares a test. Its first argument is a name, and the second is a function with the actual test code.</p> </li> <li> <p><code>expect()</code> creates an assertion. It takes a single argument, typically a value generated by the code being tested, and returns an object that provides a set of matcher functions.</p> </li> <li> <p><code>toBe()</code> is a matcher that performs a strict equality test between the value being tested (the <code>expect()</code> argument) and the expected value (its own argument).</p> </li> </ol> <p>Note the grammatical convention here: the test suite name (\"<code>greeting()</code>\") is a noun, and the test name (\"<code>says hello</code>\") is a verb. Together, they form a complete sentence describing the functionality covered by the test (\"<code>greeting()</code> says hello\").</p> <p>This convention helps make test output easy to read. You can learn more about all of these methods in the Jest API docs.</p> <pre><code>$ npm test\n\n\nPASS ./greeting.test.js\n    greeting()\n        \u2713 says hello (1 ms)\n\nTest Suites: 1 passed, 1 total\nTests:\n1 passed, 1 total\nSnapshots:\n0 total\nTime:\n0.159 s\nRan all test suites\n</code></pre> <p>Excellent! Jest found the test file, ran the test, and confirmed that <code>greeting('Jest')</code> produces the string '<code>Hello, Jest!</code>'.</p> <p>You can go ahead and delete <code>greeting.test.js</code>:</p>"},{"location":"testing/react/#the-tao-of-test-driven-development","title":"The Tao of Test-Driven Development","text":"<p>Test-driven development (TDD) is sometimes defined as writing tests first.</p> <p>Although that\u2019s an important part of the methodology, it\u2019s not the essence. The essence of TDD is rapid iteration. You\u2019ll find that you learn more quickly from iterating\u2014writing small, easy-to-understand pieces of code one at a time\u2014than you would from trying to plan out a complex program from the ground up.</p>"},{"location":"testing/react/#reference","title":"Reference","text":"<ul> <li>Test-Driven React, 2nd Edition by Trevor Burnham</li> </ul>"},{"location":"testing/types/","title":"Types","text":""},{"location":"testing/types/#types-of-testing-in-web-applications","title":"Types of Testing in Web Applications","text":"<p>Here\u2019s a breakdown of the main testing types you\u2019ll encounter:</p>"},{"location":"testing/types/#1-unit-testing","title":"1. Unit Testing","text":"<ul> <li> <p>What it is: Tests individual functions, components, or modules in isolation (e.g., a React component or a utility function).</p> </li> <li> <p>Tools:</p> <ul> <li>Jest: A popular testing framework for JavaScript and React. It\u2019s often paired with React Testing Library.</li> <li>Vitest: A faster alternative to Jest, especially good with modern JS frameworks.</li> </ul> </li> <li> <p>When to use: For small, reusable pieces of code (e.g., a button component or a helper function).</p> </li> <li>Example: Testing if a function <code>add(2, 3)</code> returns <code>5</code>.</li> </ul> Example <ul> <li>What: Tests a single React component in isolation.</li> <li>Example: Testing a <code>Button</code> component.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <pre><code>// Button.js\nexport const Button = ({ label, onClick }) =&gt; (\n    &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;\n);\n\n// Button.test.js\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport { Button } from \"./Button\";\n\ntest(\"renders button and handles click\", () =&gt; {\n    const handleClick = jest.fn(); // Mock function to track clicks\n    render(&lt;Button label=\"Click me\" onClick={handleClick} /&gt;);\n\n    const button = screen.getByText(\"Click me\");\n    expect(button).toBeInTheDocument(); // Check if it renders\n\n    fireEvent.click(button); // Simulate click\n    expect(handleClick).toHaveBeenCalledTimes(1); // Check if click handler works\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code></li> </ul>"},{"location":"testing/types/#2-integration-testing","title":"2. Integration Testing","text":"<ul> <li>What it is: Tests how different parts of your app work together (e.g., a React component calling an API).</li> <li> <p>Tools:</p> <ul> <li>Jest + React Testing Library: For testing component interactions.</li> <li>Cypress (component testing): For testing how components integrate in a real browser-like environment.</li> </ul> </li> <li> <p>When to use: When you want to ensure modules or components collaborate correctly.</p> </li> <li>Example: Testing if a form submission triggers an API call and updates the UI.</li> </ul> Example <ul> <li>What: Tests how components work together, e.g., a form submitting data.</li> <li>Example: Testing a <code>Form</code> component that updates state.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <pre><code>// Form.js\nimport { useState } from 'react';\n\nexport const Form = ({ onSubmit }) =&gt; {\n    const [input, setInput] = useState('');\n    return (\n        &lt;form onSubmit={(e) =&gt; { e.preventDefault(); onSubmit(input); }}&gt;\n            &lt;input value={input} onChange={(e) =&gt; setInput(e.target.value)} /&gt;\n            &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\n// Form.test.js\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Form } from './Form';\n\ntest('form submits input value', () =&gt; {\n    const handleSubmit = jest.fn();\n    render(&lt;Form onSubmit={handleSubmit} /&gt;);\n\n    const input = screen.getByRole('textbox');\n    const button = screen.getByText('Submit');\n\n    fireEvent.change(input, { target: { value: 'Hello' } }); // Type in input\n    fireEvent.click(button); // Submit form\n\n    expect(handleSubmit).toHaveBeenCalledWith('Hello'); // Check if value is passed\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code></li> </ul>"},{"location":"testing/types/#3-end-to-end-e2e-testing","title":"3. End-to-End (E2E) Testing","text":"<ul> <li>What it is: Simulates real user scenarios across the entire app (e.g., logging in, navigating pages, submitting forms).</li> <li> <p>Tools:</p> <ul> <li>Cypress: Great for browser-based E2E testing, easy to set up.</li> <li>Playwright: A newer, powerful option that supports multiple browsers and is fast.</li> <li>Puppeteer: Good for headless browser testing, though less user-friendly than Cypress or Playwright.</li> </ul> </li> <li> <p>When to use: To verify the full flow of your app in a production-like environment.</p> </li> <li>Example: Testing the entire checkout process in an e-commerce app.</li> </ul> Example <ul> <li>What: Tests a full user flow in a browser-like environment.</li> <li>Example: Submitting a form and checking the result.</li> <li>Tools: Cypress.</li> </ul> <pre><code>// cypress/e2e/form.cy.js\ndescribe('Form Submission', () =&gt; {\n    it('submits form and shows success message', () =&gt; {\n        cy.visit('/'); // Visit your Next.js app\u2019s homepage\n        cy.get('input').type('Hello'); // Type into input\n        cy.get('button').contains('Submit').click(); // Click submit\n        cy.get('#success-message').should('contain', 'Submitted: Hello'); // Check result\n    });\n});\n</code></pre> <ul> <li> <p>Setup: Install Cypress (<code>npm install --save-dev cypress</code>), then run <code>npx cypress</code> open.</p> </li> <li> <p>App Code: Assumes a <code>Next.js</code> page with a form and a success message div.</p> </li> </ul>"},{"location":"testing/types/#4-snapshot-testing","title":"4. Snapshot Testing","text":"<ul> <li>What it is: Captures the rendered output of a React component and compares it to a saved \u201csnapshot\u201d to detect changes.</li> <li>Tools: Jest (with its built-in snapshot feature) + React Testing Library.</li> <li>When to use: To catch unintended UI changes in React components.</li> <li>Example: Ensuring a <code>&lt;Button /&gt;</code> component\u2019s HTML structure doesn\u2019t change unexpectedly.</li> </ul> Example <ul> <li>What: Captures a component\u2019s rendered output and compares it later.</li> <li>Example: Testing a <code>Button</code> component\u2019s structure.</li> <li>Tools: Jest.</li> </ul> <pre><code>// Button.js (same as above)\nexport const Button = ({ label }) =&gt; &lt;button&gt;{label}&lt;/button&gt;;\n\n// Button.test.js\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ntest('matches snapshot', () =&gt; {\n    const { asFragment } = render(&lt;Button label=\"Click me\" /&gt;);\n    expect(asFragment()).toMatchSnapshot(); // Creates/updates snapshot\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code> (First run creates a <code>__snapshots__</code> folder; subsequent runs compare against it.)</li> </ul>"},{"location":"testing/types/#5-visual-regression-testing","title":"5. Visual Regression Testing","text":"<ul> <li> <p>What it is: Checks for visual differences in the UI (e.g., layout shifts, color changes).</p> </li> <li> <p>Tools:</p> <ul> <li>Storybook + Chromatic: For component-level visual testing.</li> <li>Percy: Integrates with Cypress or Playwright for full-page visual checks.</li> </ul> </li> <li> <p>When to use: When UI consistency is critical.</p> </li> <li>Example: Verifying a redesigned button still looks correct across pages.</li> </ul> Example <ul> <li>What: Checks for visual changes in the UI.</li> <li>Example: Testing a button\u2019s appearance with Percy and Cypress.</li> <li>Tools: Cypress + Percy.</li> </ul> <pre><code>// cypress/e2e/button.cy.js\ndescribe('Button Visual Test', () =&gt; {\n    it('looks correct', () =&gt; {\n        cy.visit('/'); // Load page with button\n        cy.get('button').contains('Click me');\n        cy.percySnapshot('Button Default State'); // Takes a screenshot\n    });\n});\n</code></pre> <ul> <li>Setup: Install Percy (<code>npm install --save-dev @percy/cypress</code>), set up Percy token, run <code>npx cypress run</code> with Percy integration.</li> </ul>"},{"location":"testing/types/#6-performance-testing","title":"6. Performance Testing","text":"<ul> <li>What it is: Measures how fast and efficient your app is under load or stress.</li> <li> <p>Tools:</p> <ul> <li>Lighthouse: Built into Chrome DevTools, great for Next.js apps.</li> <li>WebPageTest: For detailed performance analysis.</li> </ul> </li> <li> <p>When to use: To optimize load times and responsiveness.</p> </li> <li>Example: Checking if your Next.js app\u2019s server-side rendering meets performance goals.</li> </ul> Example <ul> <li>What: Measures app performance metrics.</li> <li>Example: Using Lighthouse to audit a <code>Next.js</code> page.</li> <li>Tools: Lighthouse (via Chrome DevTools or CLI).</li> </ul> <pre><code># Install Lighthouse CLI\nnpm install -g lighthouse\n\n# Run Lighthouse on your local Next.js app\nlighthouse http://localhost:3000 --view\n</code></pre> <ul> <li> <p>Output: Generates a report with scores for performance, SEO, etc.</p> </li> <li> <p>App Code: Run your Next.js app locally (<code>npm run dev</code>) first.</p> </li> </ul>"},{"location":"testing/types/#7-accessibility-a11y-testing","title":"7. Accessibility (a11y) Testing","text":"<ul> <li> <p>What it is: Ensures your app is usable by people with disabilities.</p> </li> <li> <p>Tools:</p> <ul> <li>axe-core: Integrates with Jest or Cypress.</li> <li>Lighthouse: Includes an accessibility audit.</li> </ul> </li> <li> <p>When to use: To comply with standards like WCAG and improve inclusivity.</p> </li> <li> <p>Example: Testing if a form has proper ARIA labels.</p> </li> </ul> Example <ul> <li>What: Ensures the app is accessible.</li> <li>Example: Testing a form for accessibility issues.</li> <li>Tools: Jest + axe-core.</li> </ul> <pre><code>// Form.js (same as above)\n\n// Form.test.js\nimport { render, screen } from '@testing-library/react';\nimport { axe } from 'jest-axe';\nimport { Form } from './Form';\n\ntest('form is accessible', async () =&gt; {\n    const { container } = render(&lt;Form onSubmit={() =&gt; {}} /&gt;);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations(); // Fails if accessibility issues are found\n});\n</code></pre> <ul> <li>Setup: Install axe (<code>npm install --save-dev jest-axe</code>), run <code>npx jest</code>.</li> </ul>"},{"location":"testing/types/#8-manual-testing","title":"8. Manual Testing","text":"<ul> <li>What it is: Human-driven testing without automation, exploring the app for bugs or usability issues.</li> <li>Tools: None, just your browser and app.</li> <li>When to use: For exploratory testing or when automation isn\u2019t feasible yet.</li> <li>Example: Clicking through your app to see if anything breaks.</li> </ul> Example <ul> <li>What: Human exploration of the app.</li> <li>Example: Testing a form manually.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <p>Steps:</p> <ol> <li>Open your Next.js app in the browser (<code>npm run dev</code>).</li> <li>Go to the form page.</li> <li>Type \u201cHello\u201d in the input.</li> <li>Click \u201cSubmit.\u201d</li> <li>Verify a success message appears (e.g., \u201cSubmitted: Hello\u201d).</li> </ol> <p>Tools: Just your browser (e.g., Chrome).</p> Notes <ul> <li>Setup: For most automated tests, you\u2019ll need to install dependencies and configure your project (e.g., add Jest to Next.js via <code>next/jest</code>).</li> <li>Next.js: These examples work well with Next.js; adjust paths or imports as needed (e.g., <code>pages/</code> for E2E).</li> <li>Scaling: Start with unit tests, then add others based on your app\u2019s needs.</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/frontend/","title":"Frontend","text":""},{"location":"blog/category/testing/","title":"Testing","text":""}]}