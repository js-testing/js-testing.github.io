{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Unit tests are great for peace of mind and reducing software errors. You should always make the time to test.</p>"},{"location":"#types-of-testing","title":"Types of Testing","text":""},{"location":"#js-event-loop","title":"JS Event Loop","text":"<ul> <li>\u2728\u267b\ufe0f JavaScript Visualized: Event Loop</li> </ul>"},{"location":"#js-event-loop-reference","title":"JS Event Loop Reference","text":"<ul> <li>Youtube: JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue</li> <li>Dev.to Blog: JavaScript Visualized: Event Loop </li> <li>Source: JavaScript Visualized: Event Loop, Web APIs, (Micro)task Queue</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Top 11 JavaScript Testing Frameworks: Everything You Need to Know</li> <li> <p>JavaScript unit testing frameworks in 2024: A comparison</p> </li> <li> <p>How to write your first unit test in JavaScript</p> </li> <li> <p>JS Unit Testing Frameworks Comparison</p> </li> <li> <p>Book</p> </li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"testing/developer-vs-qa/","title":"Dev vs QA Role","text":""},{"location":"testing/developer-vs-qa/#developer-vs-qa-role-in-testing","title":"Developer vs QA role in testing","text":"<p>In React development, the responsibility for writing unit tests, integration tests, and end-to-end (E2E) tests can vary depending on the team's structure and workflow. However, here is a general breakdown:</p>"},{"location":"testing/developer-vs-qa/#developers-role","title":"Developer's Role","text":"<p>React developers are typically responsible for writing unit tests and integration tests:</p> <ul> <li> <p>Unit Tests: These test individual components in isolation to ensure they function as expected (e.g., testing button clicks or state changes). Developers often use tools like Jest and React Testing Library for these tests.</p> </li> <li> <p>Integration Tests: These verify how multiple components interact with each other, ensuring proper functionality when components work together. Developers usually handle these tests as part of their coding workflow.</p> </li> </ul>"},{"location":"testing/developer-vs-qa/#qa-engineers-role","title":"QA Engineer's Role","text":"<p>Quality Assurance (QA) engineers focus more on end-to-end (E2E) testing and overall application quality:</p> <ul> <li> <p>E2E Tests: These simulate real user behavior across the entire application to ensure it works as intended in real-world scenarios. QA engineers typically design and execute these tests using tools like Cypress or Selenium.</p> </li> <li> <p>QA engineers also document testing phases, report bugs, and collaborate with developers to troubleshoot issues.</p> </li> </ul>"},{"location":"testing/developer-vs-qa/#shared-responsibility","title":"Shared Responsibility","text":"<p>In modern DevOps environments, testing responsibilities are often shared:</p> <ul> <li> <p>Developers are involved in early-stage testing to catch bugs during development.</p> </li> <li> <p>QA engineers ensure the application meets defined quality standards before release.</p> </li> </ul> <p>As a React developer, you should focus on unit and integration tests but may occasionally contribute to E2E testing, especially in smaller teams without dedicated QA personnel.</p> <ul> <li>Test behaviour, not the implementation</li> <li>Refactoring shouldn't break tests</li> </ul> <p>by - What I've Learned About Testing React Apps - Unit Tests </p>"},{"location":"testing/developer-vs-qa/#reference","title":"Reference","text":"<ul> <li>How To Write Integration Tests With Jest And React Testing Library</li> <li>React Testing: How to test React components?</li> <li>Guide to Hiring a React Developer with Testing and QA Skills</li> <li> <p>What I've Learned About Testing React Apps - Unit Tests</p> </li> <li> <p>Understanding the Roles in Quality Assurance</p> </li> <li>QA Tester job description</li> <li> <p>What Is a QA Tester?</p> </li> <li> <p>What is E2E? A guide to end-to-end testing</p> </li> </ul>"},{"location":"testing/intro/","title":"Overview","text":""},{"location":"testing/intro/#testing","title":"Testing","text":"<p>Testing is a crucial part of web application development, ensuring your app works as expected, is reliable, and provides a good user experience. Since you\u2019ve built applications with JavaScript, React, and Next.js but haven\u2019t done testing yet, I\u2019ll walk you through the types of testing commonly used in web applications, explain where to start, and address whether you should test first or later.</p> <p></p> <ol> <li>Unit Testing</li> <li>Integration Testing</li> <li>End-to-End (E2E) Testing</li> <li> <p>Other Types</p> <ul> <li>Snapshot</li> <li>Visual Regression</li> <li>Performance</li> <li>Accessibility</li> <li>Manual</li> </ul> </li> </ol>"},{"location":"testing/types/","title":"Types","text":""},{"location":"testing/types/#types-of-testing-in-web-applications","title":"Types of Testing in Web Applications","text":"<p>Here\u2019s a breakdown of the main testing types you\u2019ll encounter:</p>"},{"location":"testing/types/#1-unit-testing","title":"1. Unit Testing","text":"<ul> <li> <p>What it is: Tests individual functions, components, or modules in isolation (e.g., a React component or a utility function).</p> </li> <li> <p>Tools:</p> <ul> <li>Jest: A popular testing framework for JavaScript and React. It\u2019s often paired with React Testing Library.</li> <li>Vitest: A faster alternative to Jest, especially good with modern JS frameworks.</li> </ul> </li> <li> <p>When to use: For small, reusable pieces of code (e.g., a button component or a helper function).</p> </li> <li>Example: Testing if a function <code>add(2, 3)</code> returns <code>5</code>.</li> </ul> Example <ul> <li>What: Tests a single React component in isolation.</li> <li>Example: Testing a <code>Button</code> component.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <pre><code>// Button.js\nexport const Button = ({ label, onClick }) =&gt; (\n    &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;\n);\n\n// Button.test.js\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport { Button } from \"./Button\";\n\ntest(\"renders button and handles click\", () =&gt; {\n    const handleClick = jest.fn(); // Mock function to track clicks\n    render(&lt;Button label=\"Click me\" onClick={handleClick} /&gt;);\n\n    const button = screen.getByText(\"Click me\");\n    expect(button).toBeInTheDocument(); // Check if it renders\n\n    fireEvent.click(button); // Simulate click\n    expect(handleClick).toHaveBeenCalledTimes(1); // Check if click handler works\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code></li> </ul>"},{"location":"testing/types/#2-integration-testing","title":"2. Integration Testing","text":"<ul> <li>What it is: Tests how different parts of your app work together (e.g., a React component calling an API).</li> <li> <p>Tools:</p> <ul> <li>Jest + React Testing Library: For testing component interactions.</li> <li>Cypress (component testing): For testing how components integrate in a real browser-like environment.</li> </ul> </li> <li> <p>When to use: When you want to ensure modules or components collaborate correctly.</p> </li> <li>Example: Testing if a form submission triggers an API call and updates the UI.</li> </ul> Example <ul> <li>What: Tests how components work together, e.g., a form submitting data.</li> <li>Example: Testing a <code>Form</code> component that updates state.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <pre><code>// Form.js\nimport { useState } from 'react';\n\nexport const Form = ({ onSubmit }) =&gt; {\n    const [input, setInput] = useState('');\n    return (\n        &lt;form onSubmit={(e) =&gt; { e.preventDefault(); onSubmit(input); }}&gt;\n            &lt;input value={input} onChange={(e) =&gt; setInput(e.target.value)} /&gt;\n            &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\n// Form.test.js\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Form } from './Form';\n\ntest('form submits input value', () =&gt; {\n    const handleSubmit = jest.fn();\n    render(&lt;Form onSubmit={handleSubmit} /&gt;);\n\n    const input = screen.getByRole('textbox');\n    const button = screen.getByText('Submit');\n\n    fireEvent.change(input, { target: { value: 'Hello' } }); // Type in input\n    fireEvent.click(button); // Submit form\n\n    expect(handleSubmit).toHaveBeenCalledWith('Hello'); // Check if value is passed\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code></li> </ul>"},{"location":"testing/types/#3-end-to-end-e2e-testing","title":"3. End-to-End (E2E) Testing","text":"<ul> <li>What it is: Simulates real user scenarios across the entire app (e.g., logging in, navigating pages, submitting forms).</li> <li> <p>Tools:</p> <ul> <li>Cypress: Great for browser-based E2E testing, easy to set up.</li> <li>Playwright: A newer, powerful option that supports multiple browsers and is fast.</li> <li>Puppeteer: Good for headless browser testing, though less user-friendly than Cypress or Playwright.</li> </ul> </li> <li> <p>When to use: To verify the full flow of your app in a production-like environment.</p> </li> <li>Example: Testing the entire checkout process in an e-commerce app.</li> </ul> Example <ul> <li>What: Tests a full user flow in a browser-like environment.</li> <li>Example: Submitting a form and checking the result.</li> <li>Tools: Cypress.</li> </ul> <pre><code>// cypress/e2e/form.cy.js\ndescribe('Form Submission', () =&gt; {\n    it('submits form and shows success message', () =&gt; {\n        cy.visit('/'); // Visit your Next.js app\u2019s homepage\n        cy.get('input').type('Hello'); // Type into input\n        cy.get('button').contains('Submit').click(); // Click submit\n        cy.get('#success-message').should('contain', 'Submitted: Hello'); // Check result\n    });\n});\n</code></pre> <ul> <li> <p>Setup: Install Cypress (<code>npm install --save-dev cypress</code>), then run <code>npx cypress</code> open.</p> </li> <li> <p>App Code: Assumes a <code>Next.js</code> page with a form and a success message div.</p> </li> </ul>"},{"location":"testing/types/#4-snapshot-testing","title":"4. Snapshot Testing","text":"<ul> <li>What it is: Captures the rendered output of a React component and compares it to a saved \u201csnapshot\u201d to detect changes.</li> <li>Tools: Jest (with its built-in snapshot feature) + React Testing Library.</li> <li>When to use: To catch unintended UI changes in React components.</li> <li>Example: Ensuring a <code>&lt;Button /&gt;</code> component\u2019s HTML structure doesn\u2019t change unexpectedly.</li> </ul> Example <ul> <li>What: Captures a component\u2019s rendered output and compares it later.</li> <li>Example: Testing a <code>Button</code> component\u2019s structure.</li> <li>Tools: Jest.</li> </ul> <pre><code>// Button.js (same as above)\nexport const Button = ({ label }) =&gt; &lt;button&gt;{label}&lt;/button&gt;;\n\n// Button.test.js\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ntest('matches snapshot', () =&gt; {\n    const { asFragment } = render(&lt;Button label=\"Click me\" /&gt;);\n    expect(asFragment()).toMatchSnapshot(); // Creates/updates snapshot\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code> (First run creates a <code>__snapshots__</code> folder; subsequent runs compare against it.)</li> </ul>"},{"location":"testing/types/#5-visual-regression-testing","title":"5. Visual Regression Testing","text":"<ul> <li> <p>What it is: Checks for visual differences in the UI (e.g., layout shifts, color changes).</p> </li> <li> <p>Tools:</p> <ul> <li>Storybook + Chromatic: For component-level visual testing.</li> <li>Percy: Integrates with Cypress or Playwright for full-page visual checks.</li> </ul> </li> <li> <p>When to use: When UI consistency is critical.</p> </li> <li>Example: Verifying a redesigned button still looks correct across pages.</li> </ul> Example <ul> <li>What: Checks for visual changes in the UI.</li> <li>Example: Testing a button\u2019s appearance with Percy and Cypress.</li> <li>Tools: Cypress + Percy.</li> </ul> <pre><code>// cypress/e2e/button.cy.js\ndescribe('Button Visual Test', () =&gt; {\n    it('looks correct', () =&gt; {\n        cy.visit('/'); // Load page with button\n        cy.get('button').contains('Click me');\n        cy.percySnapshot('Button Default State'); // Takes a screenshot\n    });\n});\n</code></pre> <ul> <li>Setup: Install Percy (<code>npm install --save-dev @percy/cypress</code>), set up Percy token, run <code>npx cypress run</code> with Percy integration.</li> </ul>"},{"location":"testing/types/#6-performance-testing","title":"6. Performance Testing","text":"<ul> <li>What it is: Measures how fast and efficient your app is under load or stress.</li> <li> <p>Tools:</p> <ul> <li>Lighthouse: Built into Chrome DevTools, great for Next.js apps.</li> <li>WebPageTest: For detailed performance analysis.</li> </ul> </li> <li> <p>When to use: To optimize load times and responsiveness.</p> </li> <li>Example: Checking if your Next.js app\u2019s server-side rendering meets performance goals.</li> </ul> Example <ul> <li>What: Measures app performance metrics.</li> <li>Example: Using Lighthouse to audit a <code>Next.js</code> page.</li> <li>Tools: Lighthouse (via Chrome DevTools or CLI).</li> </ul> <pre><code># Install Lighthouse CLI\nnpm install -g lighthouse\n\n# Run Lighthouse on your local Next.js app\nlighthouse http://localhost:3000 --view\n</code></pre> <ul> <li> <p>Output: Generates a report with scores for performance, SEO, etc.</p> </li> <li> <p>App Code: Run your Next.js app locally (<code>npm run dev</code>) first.</p> </li> </ul>"},{"location":"testing/types/#7-accessibility-a11y-testing","title":"7. Accessibility (a11y) Testing","text":"<ul> <li> <p>What it is: Ensures your app is usable by people with disabilities.</p> </li> <li> <p>Tools:</p> <ul> <li>axe-core: Integrates with Jest or Cypress.</li> <li>Lighthouse: Includes an accessibility audit.</li> </ul> </li> <li> <p>When to use: To comply with standards like WCAG and improve inclusivity.</p> </li> <li> <p>Example: Testing if a form has proper ARIA labels.</p> </li> </ul> Example <ul> <li>What: Ensures the app is accessible.</li> <li>Example: Testing a form for accessibility issues.</li> <li>Tools: Jest + axe-core.</li> </ul> <pre><code>// Form.js (same as above)\n\n// Form.test.js\nimport { render, screen } from '@testing-library/react';\nimport { axe } from 'jest-axe';\nimport { Form } from './Form';\n\ntest('form is accessible', async () =&gt; {\n    const { container } = render(&lt;Form onSubmit={() =&gt; {}} /&gt;);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations(); // Fails if accessibility issues are found\n});\n</code></pre> <ul> <li>Setup: Install axe (<code>npm install --save-dev jest-axe</code>), run <code>npx jest</code>.</li> </ul>"},{"location":"testing/types/#8-manual-testing","title":"8. Manual Testing","text":"<ul> <li>What it is: Human-driven testing without automation, exploring the app for bugs or usability issues.</li> <li>Tools: None, just your browser and app.</li> <li>When to use: For exploratory testing or when automation isn\u2019t feasible yet.</li> <li>Example: Clicking through your app to see if anything breaks.</li> </ul> Example <ul> <li>What: Human exploration of the app.</li> <li>Example: Testing a form manually.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <p>Steps:</p> <ol> <li>Open your Next.js app in the browser (<code>npm run dev</code>).</li> <li>Go to the form page.</li> <li>Type \u201cHello\u201d in the input.</li> <li>Click \u201cSubmit.\u201d</li> <li>Verify a success message appears (e.g., \u201cSubmitted: Hello\u201d).</li> </ol> <p>Tools: Just your browser (e.g., Chrome).</p> Notes <ul> <li>Setup: For most automated tests, you\u2019ll need to install dependencies and configure your project (e.g., add Jest to Next.js via <code>next/jest</code>).</li> <li>Next.js: These examples work well with Next.js; adjust paths or imports as needed (e.g., <code>pages/</code> for E2E).</li> <li>Scaling: Start with unit tests, then add others based on your app\u2019s needs.</li> </ul>"}]}