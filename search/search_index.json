{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Unit tests are great for peace of mind and reducing software errors. You should always make the time to test.</p> <p>The key difference in the test-driven development lifecycle is that before writing the feature code, a test is written.(1)</p> <ol> <li> <p>Initially, the test would be empty and will fail because the feature function does not exist yet. Now write a simple feature function, and the test will pass.</p> <p>Update the test with more checks. The test might fail. Update the feature function again, and the test will pass. Keep doing this until all the test cases are covered.</p> <p>In the end, you will have a function that is well-unit-tested. Do this for all features, and you will have a nearly bug-free code. Nearly bug-free because there are many other factors responsible for zero-defect software.</p> <ul> <li>Mastering Test-Driven Development with React by Ravi Kumar Gupta</li> </ul> </li> </ol>"},{"location":"#types-of-testing","title":"Types of Testing","text":""},{"location":"#js-event-loop","title":"JS Event Loop","text":"<ul> <li>\u2728\u267b\ufe0f JavaScript Visualized: Event Loop</li> </ul>"},{"location":"#js-event-loop-reference","title":"JS Event Loop Reference","text":"<ul> <li>Youtube: JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue</li> <li>Dev.to Blog: JavaScript Visualized: Event Loop </li> <li>Source: JavaScript Visualized: Event Loop, Web APIs, (Micro)task Queue</li> </ul>"},{"location":"#book","title":"Book","text":""},{"location":"#reference","title":"Reference","text":"<ul> <li>Top 11 JavaScript Testing Frameworks: Everything You Need to Know</li> <li> <p>JavaScript unit testing frameworks in 2024: A comparison</p> </li> <li> <p>How to write your first unit test in JavaScript</p> </li> <li> <p>JS Unit Testing Frameworks Comparison</p> </li> <li> <p>Book</p> </li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/","title":"Choosing Between Jest, Vitest, and React Testing Library","text":"","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#choosing-between-jest-vitest-and-react-testing-library","title":"Choosing Between Jest, Vitest, and React Testing Library","text":"<p>When you're starting out with testing in JavaScript or React, you'll quickly come across three major tools: Jest, Vitest, and React Testing Library. While they often appear together, they serve different purposes. In this post, we'll break down what each one does, when to use them, and which combination is best for your project.</p> <p>\ud83e\uddea Beginner-friendly guide to testing frameworks for React projects</p>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#overview","title":"\ud83d\udd0d Overview","text":"Tool Type Purpose Jest Test Runner Run JavaScript/React tests Vitest Test Runner Fast, modern alternative for Vite users React Testing Library Component Testing Test React components from a user's view","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#jest","title":"\u2705 Jest","text":"<p>Jest is the most widely used testing framework in the JavaScript world. It comes pre-configured with tools like Create React App (CRA).</p> <p>Features:</p> <ul> <li>Built-in test runner and assertion library</li> <li>Snapshot testing support</li> <li>Mocking and spies</li> <li>Works with React, Node.js, and TypeScript</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re using Create React App</li> <li>Your project does not use Vite</li> <li>You want a mature, stable testing setup</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#vitest","title":"\u26a1 Vitest","text":"<p>Vitest is a modern alternative to Jest, built specifically for the Vite ecosystem. It\u2019s designed for speed and seamless Vite integration.</p> <p>Features:</p> <ul> <li>Lightning-fast test runs</li> <li>Uses native ES modules</li> <li>Shares config with your <code>vite.config.ts</code></li> <li>Compatible with Jest-style syntax (<code>describe</code>, <code>expect</code>, etc.)</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re using Vite with React or Vue</li> <li>You want faster test performance</li> <li>You prefer modern tools with better DX</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#react-testing-library","title":"\ud83e\uddea React Testing Library","text":"<p>React Testing Library (RTL) is not a test runner. It's a helper library that lets you test React components as a user would interact with them.</p> <p>Features:</p> <ul> <li>Encourages good testing practices</li> <li>Focuses on accessibility and user interactions</li> <li>Works with both Jest and Vitest</li> </ul> <p>When to use:</p> <ul> <li>You\u2019re testing React components</li> <li>You care about testing UI like a user would</li> <li>You\u2019re already using Jest or Vitest</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#should-you-use-jest-or-vitest","title":"\u2694\ufe0f Should You Use Jest or Vitest?","text":"<p>You should only use one, not both.</p> Your Project Uses Use This Create React App \u2705 Jest Vite + React \u2705 Vitest Legacy Node project \u2705 Jest New, modern React app \u2705 Vitest","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#final-recommendation-for-beginners","title":"\u2705 Final Recommendation for Beginners","text":"You Are Using Install These Create React App <code>jest</code> (comes with CRA), <code>@testing-library/react</code> Vite + React <code>vitest</code>, <code>@testing-library/react</code>, <code>jsdom</code>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#sample-vitest-react-testing-library-setup","title":"\ud83d\udee0\ufe0f Sample Vitest + React Testing Library Setup","text":"<p>Install:</p> <pre><code>npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom\n</code></pre> <p>In <code>vite.config.ts</code>:</p> <pre><code>import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: './setupTests.ts',\n  },\n})\n</code></pre> <p>In <code>setupTests.ts</code>:</p> <pre><code>import '@testing-library/jest-dom'\n</code></pre>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/21/choosing-between-jest-vitest-and-react-testing-library/#summary","title":"\ud83d\udccc Summary","text":"<ul> <li>Use Jest or Vitest \u2014 not both.</li> <li>Pair either one with React Testing Library for component testing.</li> <li>Use Jest for CRA, Vitest for Vite.</li> <li>Focus on writing tests that reflect real user behavior.</li> </ul>","tags":["jest","vitest","react","testing","frontend"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/","title":"Understanding the Difference Between jsdom and @testing-library/jest-dom","text":"","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#understanding-the-difference-between-jsdom-and-testing-libraryjest-dom","title":"Understanding the Difference Between <code>jsdom</code> and <code>@testing-library/jest-dom</code>","text":"<p>Yes, exactly \u2014 <code>jsdom</code> and <code>@testing-library/jest-dom</code> are completely different things, but they often work together in testing setups.</p> <p>vitest: The testing framework.</p> Installation<pre><code>npm install --save-dev vitest\n</code></pre> <p>After installing <code>vitest</code>, we will have to add a script to our <code>package.json</code> file to run our test.</p> package.json<pre><code>{\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n</code></pre> <p>By default, Vitest requires you to import basic functions like describe and expect. To make these available as globals, you\u2019ll need to make a couple of configuration tweaks. (1)</p> <ol> <li> <p>First, update <code>vite.config.tsx</code> to use the <code>defineConfig</code> function from <code>vitest/config</code>, and enable the <code>test.globals</code> flag:</p> vite.config.ts<pre><code>import { defineConfig } from \"vitest/config\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n  },\n});\n</code></pre> <p>Test Drivern React, Second Edition by Trevor Burnham</p> </li> </ol>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#what-is-jsdom","title":"What is <code>jsdom</code>?","text":"<ul> <li><code>jsdom</code> is a JavaScript-based implementation of the browser\u2019s DOM.</li> <li>It runs inside Node.js to simulate a real browser environment.</li> <li>Because Node.js does not have a native DOM, <code>jsdom</code> provides essential browser APIs like <code>window</code>, <code>document</code>, and <code>HTMLElement</code>.</li> <li>This environment lets you render UI components (React, Vue, etc.) and interact with the DOM during tests.</li> <li>Without <code>jsdom</code>, you can\u2019t test UI code that depends on the DOM in Node.js.</li> </ul> Installation<pre><code>npm install jsdom --save-dev\n</code></pre> <p>After installing <code>jsdom</code>, we have to include <code>jsdom</code> in the Vite configuration file, which you can find at the root of your React project <code>vite.config.js</code></p> <pre><code>import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    // \ud83d\udc4b add the line below to add jsdom to vite\n    environment: \"jsdom\",\n  },\n});\n</code></pre>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#what-is-testing-libraryjest-dom","title":"What is <code>@testing-library/jest-dom</code>?","text":"<ul> <li><code>@testing-library/jest-dom</code> is a library that adds custom Jest matchers for asserting on DOM nodes.</li> <li> <p>Examples of matchers it provides:</p> <ul> <li><code>.toBeInTheDocument()</code></li> <li><code>.toHaveTextContent()</code></li> <li><code>.toHaveAttribute()</code></li> <li><code>.toHaveClass()</code></li> </ul> </li> <li> <p>These matchers make your test assertions more readable and expressive.</p> </li> <li>However, since they assert on DOM elements, they require a DOM environment to work.</li> </ul> Installation<pre><code>npm install @testing-library/react @testing-library/jest-dom --save-dev\n</code></pre> Explanation <ul> <li><code>@testing-library/react</code>: Provides utilities to test React components.</li> <li><code>@testing-library/jest-dom</code>: Adds custom matchers to Jest and Vitest for DOM node assertions.</li> <li><code>@testing-library/user-event</code>: Simulates user interactions with the DOM.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#how-do-jsdom-and-jest-dom-work-together","title":"How Do <code>jsdom</code> and <code>jest-dom</code> Work Together?","text":"<code>jsdom</code> <code>@testing-library/jest-dom</code> Simulates the browser\u2019s DOM Provides expressive matchers for testing DOM Enables rendering and DOM APIs Makes assertions on DOM nodes easier Used as a test environment in Node Extends Jest or Vitest assertion library In short: <ul> <li><code>jsdom</code> creates the DOM environment your components run in.</li> <li><code>jest-dom</code> provides nicer assertions you use to test the DOM elements in that environment.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#do-you-always-need-both","title":"Do You Always Need Both?","text":"<ul> <li>No, but often yes!</li> <li>If you test pure functions or logic without DOM, you don\u2019t need <code>jsdom</code> or <code>jest-dom</code>.</li> <li>If you test UI components or DOM manipulation, you need <code>jsdom</code> to simulate the DOM and <code>jest-dom</code> to write readable assertions.</li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#example-vitest-setup","title":"Example Vitest Setup","text":"<pre><code>// vitest.config.ts\nimport { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    environment: \"jsdom\", // enable jsdom environment\n    setupFiles: \"./setupTests.ts\",\n  },\n});\n</code></pre> <pre><code>// setupTests.ts\nimport \"@testing-library/jest-dom\"; // import jest-dom matchers\n</code></pre>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#summary","title":"Summary","text":"Tool Purpose <code>jsdom</code> Simulates browser DOM in Node.js tests <code>@testing-library/jest-dom</code> Adds readable matchers to assert on DOM nodes <p>Using both together helps you write effective and easy-to-understand frontend tests.</p>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"blog/2025/05/22/understanding-the-difference-between-jsdom-and-testing-libraryjest-dom/#reference","title":"Reference","text":"<ul> <li>Medium: Vitest with React Testing Library In React(created with Vite)</li> <li>Vitest with React Testing Library</li> <li>Testing React Applications with Vitest: A Comprehensive Guide </li> </ul>","tags":["jsdom","jest-dom","vitest","testing-library","frontend-testing"]},{"location":"testing/developer-vs-qa/","title":"Dev vs QA Role","text":""},{"location":"testing/developer-vs-qa/#developer-vs-qa-role-in-testing","title":"Developer vs QA role in testing","text":"<p>In React development, the responsibility for writing unit tests, integration tests, and end-to-end (E2E) tests can vary depending on the team's structure and workflow. However, here is a general breakdown:</p>"},{"location":"testing/developer-vs-qa/#developers-role","title":"Developer's Role","text":"<p>React developers are typically responsible for writing unit tests and integration tests:</p> <ul> <li> <p>Unit Tests: These test individual components in isolation to ensure they function as expected (e.g., testing button clicks or state changes). Developers often use tools like Jest and React Testing Library for these tests.</p> </li> <li> <p>Integration Tests: These verify how multiple components interact with each other, ensuring proper functionality when components work together. Developers usually handle these tests as part of their coding workflow.</p> </li> </ul>"},{"location":"testing/developer-vs-qa/#qa-engineers-role","title":"QA Engineer's Role","text":"<p>Quality Assurance (QA) engineers focus more on end-to-end (E2E) testing and overall application quality:</p> <ul> <li> <p>E2E Tests: These simulate real user behavior across the entire application to ensure it works as intended in real-world scenarios. QA engineers typically design and execute these tests using tools like Cypress or Selenium.</p> </li> <li> <p>QA engineers also document testing phases, report bugs, and collaborate with developers to troubleshoot issues.</p> </li> </ul>"},{"location":"testing/developer-vs-qa/#shared-responsibility","title":"Shared Responsibility","text":"<p>In modern DevOps environments, testing responsibilities are often shared:</p> <ul> <li> <p>Developers are involved in early-stage testing to catch bugs during development.</p> </li> <li> <p>QA engineers ensure the application meets defined quality standards before release.</p> </li> </ul> <p>As a React developer, you should focus on unit and integration tests but may occasionally contribute to E2E testing, especially in smaller teams without dedicated QA personnel.</p> <ul> <li>Test behaviour, not the implementation</li> <li>Refactoring shouldn't break tests</li> </ul> <p>by - What I've Learned About Testing React Apps - Unit Tests </p>"},{"location":"testing/developer-vs-qa/#reference","title":"Reference","text":"<ul> <li>How To Write Integration Tests With Jest And React Testing Library</li> <li>React Testing: How to test React components?</li> <li>Guide to Hiring a React Developer with Testing and QA Skills</li> <li> <p>What I've Learned About Testing React Apps - Unit Tests</p> </li> <li> <p>Understanding the Roles in Quality Assurance</p> </li> <li>QA Tester job description</li> <li> <p>What Is a QA Tester?</p> </li> <li> <p>What is E2E? A guide to end-to-end testing</p> </li> </ul>"},{"location":"testing/intro/","title":"Overview","text":""},{"location":"testing/intro/#testing","title":"Testing","text":"<p>Testing is a crucial part of web application development, ensuring your app works as expected, is reliable, and provides a good user experience. Since you\u2019ve built applications with JavaScript, React, and Next.js but haven\u2019t done testing yet, I\u2019ll walk you through the types of testing commonly used in web applications, explain where to start, and address whether you should test first or later.</p> <p></p> <p></p>"},{"location":"testing/intro/#starting","title":"Starting","text":"<p>Deciding where to start with testing or which type is \"most important\" depends on your goals, your app\u2019s current state, and your experience level. Since you\u2019ve built an app with JavaScript, React, and Next.js but haven\u2019t done any testing yet, I\u2019ll break this down to help you choose.</p> Where Should You Start? <p>For someone new to testing with an existing app, Unit Testing is the best starting point. Here\u2019s why:</p> <ul> <li>Ease of Learning: Unit tests focus on small, isolated pieces (e.g., a single React component or function), making them simpler to understand and write compared to broader tests like E2E.</li> <li>Quick Feedback: They run fast and give immediate results, helping you build confidence in testing.</li> <li>Foundation: Mastering unit testing sets you up to tackle more complex types later (e.g., integration or E2E).</li> <li>Practical for Your Stack: React and Next.js are component-based, so unit testing aligns naturally with your codebase.</li> </ul> <p>Starting Example: Use Jest and React Testing Library to test a simple component (like the <code>Button</code> example from earlier). It\u2019s low effort to set up and gives you a tangible win.</p> Which Testing Type is Most Important? <p>\"Most important\" varies by context, but here\u2019s how to think about it:</p> <ol> <li> <p>Unit Testing</p> <ul> <li>Importance: High for catching bugs early in individual pieces of code. It\u2019s the backbone of a solid test suite.</li> <li>Why: Prevents small errors from snowballing. For example, ensuring a button\u2019s click handler works saves headaches later.</li> <li>When it\u2019s critical: For apps with lots of reusable logic or components (common in React/Next.js).</li> </ul> </li> <li> <p>Integration Testing</p> <ul> <li>Importance: High if your app relies on components working together (e.g., forms, API calls, state management).</li> <li>Why: Catches issues unit tests miss, like a form not passing data correctly to a parent component.</li> <li>When it\u2019s critical: If your app has complex interactions between parts.</li> </ul> </li> <li> <p>End-to-End (E2E) Testing</p> <ul> <li>Importance: Very high for ensuring the app works as a whole from a user\u2019s perspective.</li> <li>Why: Validates real-world flows (e.g., login \u2192 dashboard \u2192 logout). It\u2019s the closest to how users experience your app.</li> <li>When it\u2019s critical: For production apps where user experience and reliability are non-negotiable (e.g., e-commerce, SaaS).</li> </ul> </li> <li> <p>Other Types</p> <ul> <li>Snapshot: Useful for UI consistency but less critical early on.</li> <li>Visual Regression: Important for design-heavy apps, less so for functionality.</li> <li>Performance: Vital for user retention but can wait until core functionality is tested.</li> <li>Accessibility: Essential for inclusivity and compliance, but you can layer it in after basics.</li> <li>Manual: Good for exploration, but automation is more scalable.</li> </ul> </li> </ol> Recommendation <ul> <li>Start with Unit Testing: It\u2019s the most approachable and gives you a strong base. Set up Jest and React Testing Library, then test a few key components (e.g., a button, a form input). This builds your testing skills without overwhelming you.</li> <li>Most Important Long-Term: E2E Testing often becomes the most critical as your app grows because it ensures the entire system works for users. However, it\u2019s harder to start with due to setup complexity (e.g., Cypress) and requires a stable app to test effectively.</li> </ul>"},{"location":"testing/intro/#practical-plan","title":"Practical Plan","text":"<ol> <li> <p>Day 1: Install Jest (<code>npm install --save-dev jest</code>) and React Testing Library (<code>npm install --save-dev @testing-library/react</code>), then write a unit test for a component you\u2019ve already built. Example:</p> <pre><code>test(\"button renders\", () =&gt; {\n  render(&lt;Button label=\"Click me\" /&gt;);\n  expect(screen.getByText(\"Click me\")).toBeInTheDocument();\n});\n</code></pre> </li> <li> <p>Next Step: After a few unit tests, try an integration test for a component group (e.g., a form with a submit button).</p> </li> <li> <p>Later: Add E2E testing with Cypress once you\u2019re comfortable, focusing on key user flows.</p> </li> </ol> Why Not Start Elsewhere? <ul> <li>E2E: Too complex for a beginner; better after you\u2019ve tested smaller pieces.</li> <li>Performance/Accessibility: Important but secondary until functionality is solid.</li> <li>Manual: Useful now, but automation (starting with unit tests) scales better.</li> </ul> <p>Conclusion: Start with unit testing for its simplicity and immediate value. Long-term, E2E testing might be the most important for your app\u2019s success, but build up to it. Let me know if you need help setting up that first unit test!</p>"},{"location":"testing/react/","title":"React","text":""},{"location":"testing/react/#introducing-jest","title":"Introducing Jest","text":"<p>Jest is a test framework developed by Meta (n\u00e9e Facebook). Thanks to its rich feature set and solid performance, it\u2019s become the most popular library for testing JavaScript code in recent years.</p> Jest vs. Vitest <p>This chapter introduces you to testing with Jest, due to its popularity and ease of setup. However, later chapters will use Vitest, a Jest alternative that offers even faster performance when used in tandem with the Vite build tool. Vitest is designed for compatibility with tests written for Jest, so rest assured that the knowledge you pick up in this chapter will carry over!</p> <p>Unlike its forerunners, which expect to run in a browser environment, Jest runs in a Node process.</p>"},{"location":"testing/react/#adding-jest-as-a-dependency","title":"Adding Jest as a Dependency","text":"<p>Use npm to install the jest package:</p> <pre><code>$ npm install --save-dev jest@29.4.3\n</code></pre> <pre><code>// package.json\n{\n    ...\n    \"devDependencies\": {\n        \"jest\": \"^29.4.3\"\n    }\n}\n</code></pre> What Does the Caret (^) Before Version Numbers Mean? <p>By default, npm lists dependencies in <code>package.json</code> with a caret (<code>^</code>). The caret creates a version range that allows for minor updates and patches. So, <code>jest@^29.4.3</code> includes any version of <code>jest</code> from version <code>29.4.3</code> up to, but not including, <code>30.0.0</code>. According to <code>semver</code> principles, newer versions in that range should be backward compatible because package authors should bump the major version when making any breaking change. But be warned\u2014package authors often ignore semver principles!</p> <p>Fortunately, the other file <code>npm</code> created, <code>package-lock.json</code>, stores the exact version that was installed. As long as that lockfile is preserved, anyone who installs the project will get the exact same version of <code>jest</code> that you did. Put another way, <code>npm install</code> gives <code>package-lock.json</code> precedence over <code>package.json</code>. To install the latest version allowed by <code>package.json</code>, use the <code>npm update</code> command.</p> <p>Now Jest is installed and ready for you to use. However, it\u2019s in the project\u2019s <code>node_modules</code>, not on your PATH. To run it, you\u2019ll need to call on another tool\u2014npx.</p>"},{"location":"testing/react/#running-project-scripts-with-npm","title":"Running Project Scripts with npm","text":"<pre><code>$ npx jest --version\n29.4.3\n</code></pre> <p>The test script is special to npm; you can execute it with either <code>npm run test</code> or just <code>npm test</code>. You should see the same output that you got with npx jest:</p> <pre><code>$ npm test\n</code></pre> <p>No tests found, exiting with code 1</p>"},{"location":"testing/react/#writing-a-test","title":"Writing a Test","text":"<p>Time for your first test! Create a file called greeting.test.js:</p> <pre><code>// greeting.test.js\nconst greeting = (guest) =&gt; `Hello, ${guest}!`;\n\ndescribe(\"greeting()\", () =&gt; {\n  it(\"says hello\", () =&gt; {\n    expect(greeting(\"Jest\")).toBe(\"Hello, Jest!\");\n  });\n});\n</code></pre> <ol> <li> <p><code>describe()</code> declares a test suite, which is a grouping of tests. Its first argument is a name, and the second is a function containing one or more tests.</p> </li> <li> <p><code>it()</code> declares a test. Its first argument is a name, and the second is a function with the actual test code.</p> </li> <li> <p><code>expect()</code> creates an assertion. It takes a single argument, typically a value generated by the code being tested, and returns an object that provides a set of matcher functions.</p> </li> <li> <p><code>toBe()</code> is a matcher that performs a strict equality test between the value being tested (the <code>expect()</code> argument) and the expected value (its own argument).</p> </li> </ol> <p>Note the grammatical convention here: the test suite name (\"<code>greeting()</code>\") is a noun, and the test name (\"<code>says hello</code>\") is a verb. Together, they form a complete sentence describing the functionality covered by the test (\"<code>greeting()</code> says hello\").</p> <p>This convention helps make test output easy to read. You can learn more about all of these methods in the Jest API docs.</p> <pre><code>$ npm test\n\n\nPASS ./greeting.test.js\n    greeting()\n        \u2713 says hello (1 ms)\n\nTest Suites: 1 passed, 1 total\nTests:\n1 passed, 1 total\nSnapshots:\n0 total\nTime:\n0.159 s\nRan all test suites\n</code></pre> <p>Excellent! Jest found the test file, ran the test, and confirmed that <code>greeting('Jest')</code> produces the string '<code>Hello, Jest!</code>'.</p> <p>You can go ahead and delete <code>greeting.test.js</code>:</p>"},{"location":"testing/react/#the-tao-of-test-driven-development","title":"The Tao of Test-Driven Development","text":"<p>Test-driven development (TDD) is sometimes defined as writing tests first.</p> <p>Although that\u2019s an important part of the methodology, it\u2019s not the essence. The essence of TDD is rapid iteration. You\u2019ll find that you learn more quickly from iterating\u2014writing small, easy-to-understand pieces of code one at a time\u2014than you would from trying to plan out a complex program from the ground up.</p>"},{"location":"testing/react/#reference","title":"Reference","text":"<ul> <li>Test-Driven React, 2nd Edition by Trevor Burnham</li> </ul>"},{"location":"testing/types/","title":"Types","text":""},{"location":"testing/types/#types-of-testing-in-web-applications","title":"Types of Testing in Web Applications","text":"<p>Here\u2019s a breakdown of the main testing types you\u2019ll encounter:</p>"},{"location":"testing/types/#1-unit-testing","title":"1. Unit Testing","text":"<ul> <li> <p>What it is: Tests individual functions, components, or modules in isolation (e.g., a React component or a utility function).</p> </li> <li> <p>Tools:</p> <ul> <li>Jest: A popular testing framework for JavaScript and React. It\u2019s often paired with React Testing Library.</li> <li>Vitest: A faster alternative to Jest, especially good with modern JS frameworks.</li> </ul> </li> <li> <p>When to use: For small, reusable pieces of code (e.g., a button component or a helper function).</p> </li> <li>Example: Testing if a function <code>add(2, 3)</code> returns <code>5</code>.</li> </ul> Example <ul> <li>What: Tests a single React component in isolation.</li> <li>Example: Testing a <code>Button</code> component.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <pre><code>// Button.js\nexport const Button = ({ label, onClick }) =&gt; (\n    &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;\n);\n\n// Button.test.js\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport { Button } from \"./Button\";\n\ntest(\"renders button and handles click\", () =&gt; {\n    const handleClick = jest.fn(); // Mock function to track clicks\n    render(&lt;Button label=\"Click me\" onClick={handleClick} /&gt;);\n\n    const button = screen.getByText(\"Click me\");\n    expect(button).toBeInTheDocument(); // Check if it renders\n\n    fireEvent.click(button); // Simulate click\n    expect(handleClick).toHaveBeenCalledTimes(1); // Check if click handler works\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code></li> </ul>"},{"location":"testing/types/#2-integration-testing","title":"2. Integration Testing","text":"<ul> <li>What it is: Tests how different parts of your app work together (e.g., a React component calling an API).</li> <li> <p>Tools:</p> <ul> <li>Jest + React Testing Library: For testing component interactions.</li> <li>Cypress (component testing): For testing how components integrate in a real browser-like environment.</li> </ul> </li> <li> <p>When to use: When you want to ensure modules or components collaborate correctly.</p> </li> <li>Example: Testing if a form submission triggers an API call and updates the UI.</li> </ul> Example <ul> <li>What: Tests how components work together, e.g., a form submitting data.</li> <li>Example: Testing a <code>Form</code> component that updates state.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <pre><code>// Form.js\nimport { useState } from 'react';\n\nexport const Form = ({ onSubmit }) =&gt; {\n    const [input, setInput] = useState('');\n    return (\n        &lt;form onSubmit={(e) =&gt; { e.preventDefault(); onSubmit(input); }}&gt;\n            &lt;input value={input} onChange={(e) =&gt; setInput(e.target.value)} /&gt;\n            &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\n// Form.test.js\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Form } from './Form';\n\ntest('form submits input value', () =&gt; {\n    const handleSubmit = jest.fn();\n    render(&lt;Form onSubmit={handleSubmit} /&gt;);\n\n    const input = screen.getByRole('textbox');\n    const button = screen.getByText('Submit');\n\n    fireEvent.change(input, { target: { value: 'Hello' } }); // Type in input\n    fireEvent.click(button); // Submit form\n\n    expect(handleSubmit).toHaveBeenCalledWith('Hello'); // Check if value is passed\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code></li> </ul>"},{"location":"testing/types/#3-end-to-end-e2e-testing","title":"3. End-to-End (E2E) Testing","text":"<ul> <li>What it is: Simulates real user scenarios across the entire app (e.g., logging in, navigating pages, submitting forms).</li> <li> <p>Tools:</p> <ul> <li>Cypress: Great for browser-based E2E testing, easy to set up.</li> <li>Playwright: A newer, powerful option that supports multiple browsers and is fast.</li> <li>Puppeteer: Good for headless browser testing, though less user-friendly than Cypress or Playwright.</li> </ul> </li> <li> <p>When to use: To verify the full flow of your app in a production-like environment.</p> </li> <li>Example: Testing the entire checkout process in an e-commerce app.</li> </ul> Example <ul> <li>What: Tests a full user flow in a browser-like environment.</li> <li>Example: Submitting a form and checking the result.</li> <li>Tools: Cypress.</li> </ul> <pre><code>// cypress/e2e/form.cy.js\ndescribe('Form Submission', () =&gt; {\n    it('submits form and shows success message', () =&gt; {\n        cy.visit('/'); // Visit your Next.js app\u2019s homepage\n        cy.get('input').type('Hello'); // Type into input\n        cy.get('button').contains('Submit').click(); // Click submit\n        cy.get('#success-message').should('contain', 'Submitted: Hello'); // Check result\n    });\n});\n</code></pre> <ul> <li> <p>Setup: Install Cypress (<code>npm install --save-dev cypress</code>), then run <code>npx cypress</code> open.</p> </li> <li> <p>App Code: Assumes a <code>Next.js</code> page with a form and a success message div.</p> </li> </ul>"},{"location":"testing/types/#4-snapshot-testing","title":"4. Snapshot Testing","text":"<ul> <li>What it is: Captures the rendered output of a React component and compares it to a saved \u201csnapshot\u201d to detect changes.</li> <li>Tools: Jest (with its built-in snapshot feature) + React Testing Library.</li> <li>When to use: To catch unintended UI changes in React components.</li> <li>Example: Ensuring a <code>&lt;Button /&gt;</code> component\u2019s HTML structure doesn\u2019t change unexpectedly.</li> </ul> Example <ul> <li>What: Captures a component\u2019s rendered output and compares it later.</li> <li>Example: Testing a <code>Button</code> component\u2019s structure.</li> <li>Tools: Jest.</li> </ul> <pre><code>// Button.js (same as above)\nexport const Button = ({ label }) =&gt; &lt;button&gt;{label}&lt;/button&gt;;\n\n// Button.test.js\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ntest('matches snapshot', () =&gt; {\n    const { asFragment } = render(&lt;Button label=\"Click me\" /&gt;);\n    expect(asFragment()).toMatchSnapshot(); // Creates/updates snapshot\n});\n</code></pre> <ul> <li>Run: <code>npx jest</code> (First run creates a <code>__snapshots__</code> folder; subsequent runs compare against it.)</li> </ul>"},{"location":"testing/types/#5-visual-regression-testing","title":"5. Visual Regression Testing","text":"<ul> <li> <p>What it is: Checks for visual differences in the UI (e.g., layout shifts, color changes).</p> </li> <li> <p>Tools:</p> <ul> <li>Storybook + Chromatic: For component-level visual testing.</li> <li>Percy: Integrates with Cypress or Playwright for full-page visual checks.</li> </ul> </li> <li> <p>When to use: When UI consistency is critical.</p> </li> <li>Example: Verifying a redesigned button still looks correct across pages.</li> </ul> Example <ul> <li>What: Checks for visual changes in the UI.</li> <li>Example: Testing a button\u2019s appearance with Percy and Cypress.</li> <li>Tools: Cypress + Percy.</li> </ul> <pre><code>// cypress/e2e/button.cy.js\ndescribe('Button Visual Test', () =&gt; {\n    it('looks correct', () =&gt; {\n        cy.visit('/'); // Load page with button\n        cy.get('button').contains('Click me');\n        cy.percySnapshot('Button Default State'); // Takes a screenshot\n    });\n});\n</code></pre> <ul> <li>Setup: Install Percy (<code>npm install --save-dev @percy/cypress</code>), set up Percy token, run <code>npx cypress run</code> with Percy integration.</li> </ul>"},{"location":"testing/types/#6-performance-testing","title":"6. Performance Testing","text":"<ul> <li>What it is: Measures how fast and efficient your app is under load or stress.</li> <li> <p>Tools:</p> <ul> <li>Lighthouse: Built into Chrome DevTools, great for Next.js apps.</li> <li>WebPageTest: For detailed performance analysis.</li> </ul> </li> <li> <p>When to use: To optimize load times and responsiveness.</p> </li> <li>Example: Checking if your Next.js app\u2019s server-side rendering meets performance goals.</li> </ul> Example <ul> <li>What: Measures app performance metrics.</li> <li>Example: Using Lighthouse to audit a <code>Next.js</code> page.</li> <li>Tools: Lighthouse (via Chrome DevTools or CLI).</li> </ul> <pre><code># Install Lighthouse CLI\nnpm install -g lighthouse\n\n# Run Lighthouse on your local Next.js app\nlighthouse http://localhost:3000 --view\n</code></pre> <ul> <li> <p>Output: Generates a report with scores for performance, SEO, etc.</p> </li> <li> <p>App Code: Run your Next.js app locally (<code>npm run dev</code>) first.</p> </li> </ul>"},{"location":"testing/types/#7-accessibility-a11y-testing","title":"7. Accessibility (a11y) Testing","text":"<ul> <li> <p>What it is: Ensures your app is usable by people with disabilities.</p> </li> <li> <p>Tools:</p> <ul> <li>axe-core: Integrates with Jest or Cypress.</li> <li>Lighthouse: Includes an accessibility audit.</li> </ul> </li> <li> <p>When to use: To comply with standards like WCAG and improve inclusivity.</p> </li> <li> <p>Example: Testing if a form has proper ARIA labels.</p> </li> </ul> Example <ul> <li>What: Ensures the app is accessible.</li> <li>Example: Testing a form for accessibility issues.</li> <li>Tools: Jest + axe-core.</li> </ul> <pre><code>// Form.js (same as above)\n\n// Form.test.js\nimport { render, screen } from '@testing-library/react';\nimport { axe } from 'jest-axe';\nimport { Form } from './Form';\n\ntest('form is accessible', async () =&gt; {\n    const { container } = render(&lt;Form onSubmit={() =&gt; {}} /&gt;);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations(); // Fails if accessibility issues are found\n});\n</code></pre> <ul> <li>Setup: Install axe (<code>npm install --save-dev jest-axe</code>), run <code>npx jest</code>.</li> </ul>"},{"location":"testing/types/#8-manual-testing","title":"8. Manual Testing","text":"<ul> <li>What it is: Human-driven testing without automation, exploring the app for bugs or usability issues.</li> <li>Tools: None, just your browser and app.</li> <li>When to use: For exploratory testing or when automation isn\u2019t feasible yet.</li> <li>Example: Clicking through your app to see if anything breaks.</li> </ul> Example <ul> <li>What: Human exploration of the app.</li> <li>Example: Testing a form manually.</li> <li>Tools: Jest + React Testing Library.</li> </ul> <p>Steps:</p> <ol> <li>Open your Next.js app in the browser (<code>npm run dev</code>).</li> <li>Go to the form page.</li> <li>Type \u201cHello\u201d in the input.</li> <li>Click \u201cSubmit.\u201d</li> <li>Verify a success message appears (e.g., \u201cSubmitted: Hello\u201d).</li> </ol> <p>Tools: Just your browser (e.g., Chrome).</p> Notes <ul> <li>Setup: For most automated tests, you\u2019ll need to install dependencies and configure your project (e.g., add Jest to Next.js via <code>next/jest</code>).</li> <li>Next.js: These examples work well with Next.js; adjust paths or imports as needed (e.g., <code>pages/</code> for E2E).</li> <li>Scaling: Start with unit tests, then add others based on your app\u2019s needs.</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/frontend/","title":"Frontend","text":""},{"location":"blog/category/testing/","title":"Testing","text":""}]}